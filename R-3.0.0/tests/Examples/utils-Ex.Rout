
R version 3.0.0 (2013-04-03) -- "Masked Marvel"
Copyright (C) 2013 The R Foundation for Statistical Computing
Platform: x86_64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "utils"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('utils')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("Question")
> ### * Question
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Question
> ### Title: Documentation Shortcuts
> ### Aliases: Question ?
> ### Keywords: documentation
> 
> ### ** Examples
> 
> ?lapply
lapply                  package:base                   R Documentation

_A_p_p_l_y _a _F_u_n_c_t_i_o_n _o_v_e_r _a _L_i_s_t _o_r _V_e_c_t_o_r

_D_e_s_c_r_i_p_t_i_o_n:

     ‘lapply’ returns a list of the same length as ‘X’, each element of
     which is the result of applying ‘FUN’ to the corresponding element
     of ‘X’.

     ‘sapply’ is a user-friendly version and wrapper of ‘lapply’ by
     default returning a vector, matrix or, if ‘simplify = "array"’, an
     array if appropriate, by applying ‘simplify2array()’.  ‘sapply(x,
     f, simplify = FALSE, USE.NAMES = FALSE)’ is the same as ‘lapply(x,
     f)’.

     ‘vapply’ is similar to ‘sapply’, but has a pre-specified type of
     return value, so it can be safer (and sometimes faster) to use.

     ‘replicate’ is a wrapper for the common use of ‘sapply’ for
     repeated evaluation of an expression (which will usually involve
     random number generation).

     ‘simplify2array()’ is the utility called from ‘sapply()’ when
     ‘simplify’ is not false and is similarly called from ‘mapply()’.

_U_s_a_g_e:

     lapply(X, FUN, ...)
     
     sapply(X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE)
     
     vapply(X, FUN, FUN.VALUE, ..., USE.NAMES = TRUE)
     
     replicate(n, expr, simplify = "array")
     
     simplify2array(x, higher = TRUE)
     
_A_r_g_u_m_e_n_t_s:

       X: a vector (atomic or list) or an ‘expression’ object.  Other
          objects (including classed objects) will be coerced by
          ‘base::as.list’.

     FUN: the function to be applied to each element of ‘X’: see
          ‘Details’.  In the case of functions like ‘+’, ‘%*%’, the
          function name must be backquoted or quoted.

     ...: optional arguments to ‘FUN’.

simplify: logical or character string; should the result be simplified
          to a vector, matrix or higher dimensional array if possible?
          For ‘sapply’ it must be named and not abbreviated.  The
          default value, ‘TRUE’, returns a vector or matrix if
          appropriate, whereas if ‘simplify = "array"’ the result may
          be an ‘array’ of “rank” (=‘length(dim(.))’) one higher than
          the result of ‘FUN(X[[i]])’.

USE.NAMES: logical; if ‘TRUE’ and if ‘X’ is character, use ‘X’ as
          ‘names’ for the result unless it had names already.  Since
          this argument follows ‘...’ its name cannot be abbreviated.

FUN.VALUE: a (generalized) vector; a template for the return value from
          FUN.  See ‘Details’.

       n: integer: the number of replications.

    expr: the expression (language object, usually a call) to evaluate
          repeatedly.

       x: a list, typically returned from ‘lapply()’.

  higher: logical; if true, ‘simplify2array()’ will produce a (“higher
          rank”) array when appropriate, whereas ‘higher = FALSE’ would
          return a matrix (or vector) only.  These two cases correspond
          to ‘sapply(*, simplify = "array")’ or ‘simplify = TRUE’,
          respectively.

_D_e_t_a_i_l_s:

     ‘FUN’ is found by a call to ‘match.fun’ and typically is specified
     as a function or a symbol (e.g. a backquoted name) or a character
     string specifying a function to be searched for from the
     environment of the call to ‘lapply’.

     Function ‘FUN’ must be able to accept as input any of the elements
     of ‘X’.  If the latter is an atomic vector, ‘FUN’ will always be
     passed a length-one vector of the same type as ‘X’.

     Arguments in ‘...’ cannot have the same name as any of the other
     arguments, and care may be needed to avoid partial matching to
     ‘FUN’.  In general-purpose code it is good practice to name the
     first two arguments ‘X’ and ‘FUN’ if ‘...’ is passed through: this
     both avoids partial matching to ‘FUN’ and ensures that a sensible
     error message is given if arguments named ‘X’ or ‘FUN’ are passed
     through ‘...’.

     Simplification in ‘sapply’ is only attempted if ‘X’ has length
     greater than zero and if the return values from all elements of
     ‘X’ are all of the same (positive) length.  If the common length
     is one the result is a vector, and if greater than one is a matrix
     with a column corresponding to each element of ‘X’.

     Simplification is always done in ‘vapply’.  This function checks
     that all values of ‘FUN’ are compatible with the ‘FUN.VALUE’, in
     that they must have the same length and type.  (Types may be
     promoted to a higher type within the ordering logical < integer <
     double < complex, but not demoted.)

     Users of S4 classes should pass a list to ‘lapply’ and ‘vapply’:
     the internal coercion is done by the ‘as.list’ in the base
     namespace and not one defined by a user (e.g. by setting S4
     methods on the base function).

     ‘lapply’ and ‘vapply’ are primitive functions.

_V_a_l_u_e:

     For ‘lapply’, ‘sapply(simplify = FALSE)’ and ‘replicate(simplify =
     FALSE)’, a list.

     For ‘sapply(simplify = TRUE)’ and ‘replicate(simplify = TRUE)’: if
     ‘X’ has length zero or ‘n = 0’, an empty list.  Otherwise an
     atomic vector or matrix or list of the same length as ‘X’ (of
     length ‘n’ for ‘replicate’).  If simplification occurs, the output
     type is determined from the highest type of the return values in
     the hierarchy NULL < raw < logical < integer < double < complex <
     character < list < expression, after coercion of pairlists to
     lists.

     ‘vapply’ returns a vector or array of type matching the
     ‘FUN.VALUE’.  If ‘length(FUN.VALUE) == 1’ a vector of the same
     length as ‘X’ is returned, otherwise an array.  If ‘FUN.VALUE’ is
     not an ‘array’, the result is a matrix with ‘length(FUN.VALUE)’
     rows and ‘length(X)’ columns, otherwise an array ‘a’ with ‘dim(a)
     == c(dim(FUN.VALUE), length(X))’.

     The (Dim)names of the array value are taken from the ‘FUN.VALUE’
     if it is named, otherwise from the result of the first function
     call.  Column names of the matrix or more generally the names of
     the last dimension of the array value or names of the vector value
     are set from ‘X’ as in ‘sapply’.

_N_o_t_e:

     ‘sapply(*, simplify = FALSE, USE.NAMES = FALSE)’ is equivalent to
     ‘lapply(*)’.

     For historical reasons, the calls created by ‘lapply’ are
     unevaluated, and code has been written (e.g. ‘bquote’) that relies
     on this.  This means that the recorded call is always of the form
     ‘FUN(X[[0L]], ...)’, with ‘0L’ replaced by the current integer
     index.  This is not normally a problem, but it can be if ‘FUN’
     uses ‘sys.call’ or ‘match.call’ or if it is a primitive function
     that makes use of the call.  This means that it is often safer to
     call primitive functions with a wrapper, so that e.g. ‘lapply(ll,
     function(x) is.numeric(x))’ is required in R 2.7.1 to ensure that
     method dispatch for ‘is.numeric’ occurs correctly.

     If ‘expr’ is a function call, be aware of assumptions about where
     it is evaluated, and in particular what ‘...’ might refer to.  You
     can pass additional named arguments to a function call as
     additional named arguments to ‘replicate’: see ‘Examples’.

_R_e_f_e_r_e_n_c_e_s:

     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S
     Language_.  Wadsworth & Brooks/Cole.

_S_e_e _A_l_s_o:

     ‘apply’, ‘tapply’, ‘mapply’ for applying a function to *m*ultiple
     arguments, and ‘rapply’ for a *r*ecursive version of ‘lapply()’,
     ‘eapply’ for applying a function to each entry in an
     ‘environment’.

_E_x_a_m_p_l_e_s:

     require(stats); require(graphics)
     
     x <- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE,FALSE,FALSE,TRUE))
     # compute the list mean for each list element
     lapply(x, mean)
     # median and quartiles for each list element
     lapply(x, quantile, probs = 1:3/4)
     sapply(x, quantile)
     i39 <- sapply(3:9, seq) # list of vectors
     sapply(i39, fivenum)
     vapply(i39, fivenum,
            c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
     
     ## sapply(*, "array") -- artificial example
     (v <- structure(10*(5:8), names = LETTERS[1:4]))
     f2 <- function(x, y) outer(rep(x, length.out = 3), y)
     (a2 <- sapply(v, f2, y = 2*(1:5), simplify = "array"))
     a.2 <- vapply(v, f2, outer(1:3, 1:5), y = 2*(1:5))
     stopifnot(dim(a2) == c(3,5,4), all.equal(a2, a.2),
               identical(dimnames(a2), list(NULL,NULL,LETTERS[1:4])))
     
     hist(replicate(100, mean(rexp(10))))
     
     ## use of replicate() with parameters:
     foo <- function(x = 1, y = 2) c(x, y)
     # does not work: bar <- function(n, ...) replicate(n, foo(...))
     bar <- function(n, x) replicate(n, foo(x = x))
     bar(5, x = 3)
     

> 
> ?"for"                  # but quotes/backticks are needed
Control                  package:base                  R Documentation

_C_o_n_t_r_o_l _F_l_o_w

_D_e_s_c_r_i_p_t_i_o_n:

     These are the basic control-flow constructs of the R language.
     They function in much the same way as control statements in any
     Algol-like language.  They are all reserved words.

_U_s_a_g_e:

     if(cond) expr
     if(cond) cons.expr  else  alt.expr
     
     for(var in seq) expr
     while(cond) expr
     repeat expr
     break
     next
     
_A_r_g_u_m_e_n_t_s:

    cond: A length-one logical vector that is not ‘NA’.  Conditions of
          length greater than one are accepted with a warning, but only
          the first element is used.  Other types are coerced to
          logical if possible, ignoring any class.

     var: A syntactical name for a variable.

     seq: An expression evaluating to a vector (including a list and an
          expression) or to a pairlist or ‘NULL’.  A factor value will
          be coerced to a character vector.

expr, cons.expr, alt.expr: An _expression_ in a formal sense.  This is
          either a simple expression or a so called _compound
          expression_, usually of the form ‘{ expr1 ; expr2 }’.

_D_e_t_a_i_l_s:

     ‘break’ breaks out of a ‘for’, ‘while’ or ‘repeat’ loop; control
     is transferred to the first statement outside the inner-most loop.
     ‘next’ halts the processing of the current iteration and advances
     the looping index.  Both ‘break’ and ‘next’ apply only to the
     innermost of nested loops.

     Note that it is a common mistake to forget to put braces (‘{ ..
     }’) around your statements, e.g., after ‘if(..)’ or ‘for(....)’.
     In particular, you should not have a newline between ‘}’ and
     ‘else’ to avoid a syntax error in entering a ‘if ... else’
     construct at the keyboard or via ‘source’.  For that reason, one
     (somewhat extreme) attitude of defensive programming is to always
     use braces, e.g., for ‘if’ clauses.

     The ‘seq’ in a ‘for’ loop is evaluated at the start of the loop;
     changing it subsequently does not affect the loop.  If ‘seq’ has
     length zero the body of the loop is skipped. Otherwise the
     variable ‘var’ is assigned in turn the value of each element of
     ‘seq’. You can assign to ‘var’ within the body of the loop, but
     this will not affect the next iteration.  When the loop
     terminates, ‘var’ remains as a variable containing its latest
     value.

_V_a_l_u_e:

     ‘if’ returns the value of the expression evaluated, or ‘NULL’
     invisibly if none was (which may happen if there is no ‘else’).

     ‘for’, ‘while’ and ‘repeat’ return ‘NULL’ invisibly.  ‘for’ sets
     ‘var’ to the last used element of ‘seq’, or to ‘NULL’ if it was of
     length zero.

     ‘break’ and ‘next’ do not return a value as they transfer control
     within the loop.

_R_e_f_e_r_e_n_c_e_s:

     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S
     Language_.  Wadsworth & Brooks/Cole.

_S_e_e _A_l_s_o:

     ‘Syntax’ for the basic R syntax and operators, ‘Paren’ for
     parentheses and braces.

     ‘ifelse’, ‘switch’ for other ways to control flow.

_E_x_a_m_p_l_e_s:

     for(i in 1:5) print(1:i)
     for(n in c(2,5,10,20,50)) {
        x <- stats::rnorm(n)
        cat(n, ": ", sum(x^2), "\n", sep = "")
     }
     f <- factor(sample(letters[1:5], 10, replace = TRUE))
     for(i in unique(f)) print(i)
     

> ?`+`
Arithmetic                package:base                 R Documentation

_A_r_i_t_h_m_e_t_i_c _O_p_e_r_a_t_o_r_s

_D_e_s_c_r_i_p_t_i_o_n:

     These binary operators perform arithmetic on numeric or complex
     vectors (or objects which can be coerced to them).

_U_s_a_g_e:

     x + y
     x - y
     x * y
     x / y
     x ^ y
     x %% y
     x %/% y
     
_A_r_g_u_m_e_n_t_s:

    x, y: numeric or complex vectors or objects which can be coerced to
          such, or other objects for which methods have been written.

_D_e_t_a_i_l_s:

     The binary arithmetic operators are generic functions: methods can
     be written for them individually or via the ‘Ops’ group generic
     function.  (See ‘Ops’ for how dispatch is computed.)

     If applied to arrays the result will be an array if this is
     sensible (for example it will not if the recycling rule has been
     invoked).

     Logical vectors will be coerced to integer or numeric vectors,
     ‘FALSE’ having value zero and ‘TRUE’ having value one.

     ‘1 ^ y’ and ‘y ^ 0’ are ‘1’, _always_.  ‘x ^ y’ should also give
     the proper limit result when either argument is infinite (i.e.,
     ‘+- Inf’).

     Objects such as arrays or time-series can be operated on this way
     provided they are conformable.

     For double arguments, ‘%%’ can be subject to catastrophic loss of
     accuracy if ‘x’ is much larger than ‘y’, and a warning is given if
     this is detected.

     ‘%%’ and ‘x %/% y’ can be used for non-integer ‘y’, e.g. ‘1 %/%
     0.2’, but the results are subject to representation error and so
     may be platform-dependent.  Because the IEC 60059 representation
     of ‘0.2’ is a binary fraction slightly larger than ‘0.2’, the
     answer to ‘1 %/% 0.2’ should be ‘4’ but most platforms give ‘5’.

     Users are sometimes surprised by the value returned, for example
     why ‘(-8)^(1/3)’ is ‘NaN’.  For double inputs, R makes use of IEC
     60559 arithmetic on all platforms, together with the C system
     function ‘pow’ for the ‘^’ operator.  The relevant standards
     define the result in many corner cases.  In particular, the result
     in the example above is mandated by the C99 standard.  On many
     Unix-alike systems the command ‘man pow’ gives details of the
     values in a large number of corner cases.

     Arithmetic on type double in R is supposed to be done in ‘round to
     nearest, ties to even’ mode, but this does depend on the compiler
     and FPU being set up correctly.

_V_a_l_u_e:

     These operators return vectors containing the result of the
     element by element operations.  The elements of shorter vectors
     are recycled as necessary (with a ‘warning’ when they are recycled
     only _fractionally_).  The operators are ‘+’ for addition, ‘-’ for
     subtraction, ‘*’ for multiplication, ‘/’ for division and ‘^’ for
     exponentiation.

     ‘%%’ indicates ‘x mod y’ and ‘%/%’ indicates integer division.  It
     is guaranteed that ‘x == (x %% y) + y * ( x %/% y )’ (up to
     rounding error) unless ‘y == 0’ where the result of ‘%%’ is
     ‘NA_integer_’ or ‘NaN’ (depending on the ‘typeof’ of the
     arguments).

     If either argument is complex the result will be complex,
     otherwise if one or both arguments are numeric, the result will be
     numeric.  If both arguments are of type integer, the type of the
     result of ‘/’ and ‘^’ is numeric and for the other operators it is
     integer (with overflow, which occurs at +/- (2^31 - 1), returned
     as ‘NA_integer_’ with a warning).

     The rules for determining the attributes of the result are rather
     complicated.  Most attributes are taken from the longer argument,
     the first if they are of the same length.  Names will be copied
     from the first if it is the same length as the answer, otherwise
     from the second if that is.  For time series, these operations are
     allowed only if the series are compatible, when the class and
     ‘tsp’ attribute of whichever is a time series (the same, if both
     are) are used.  For arrays (and an array result) the dimensions
     and dimnames are taken from first argument if it is an array,
     otherwise the second.

_S_4 _m_e_t_h_o_d_s:

     These operators are members of the S4 ‘Arith’ group generic, and
     so methods can be written for them individually as well as for the
     group generic (or the ‘Ops’ group generic), with arguments ‘c(e1,
     e2)’.

_I_m_p_l_e_m_e_n_t_a_t_i_o_n _l_i_m_i_t_s:

     R is dependent on OS services (and they on FPUs) for
     floating-point arithmetic.  On all current R platforms IEC 60559
     (also known as IEEE 754) arithmetic is used, but some things in
     those standards are optional.  In particular, the support for
     _denormal numbers_ (those outside the range given by ‘.Machine’)
     may differ between platforms and even between calculations on a
     single platform.

     Another potential issue is signed zeroes: on IEC 60659 platforms
     there are two zeroes with internal representations differing by
     sign.  Where possible R treats them as the same, but for example
     direct output from C code often does not do so and may output
     ‘-0.0’ (and on Windows whether it does so or not depends on the
     version of Windows).  One place in R where the difference might be
     seen is in division by zero: ‘1/x’ is ‘Inf’ or ‘-Inf’ depending on
     the sign of zero ‘x’.

_N_o_t_e:

     ‘**’ is translated in the parser to ‘^’, but this was undocumented
     for many years.  It appears as an index entry in Becker _et al_
     (1988), pointing to the help for ‘Deprecated’ but is not actually
     mentioned on that page.  Even though it had been deprecated in S
     for 20 years, it was still accepted in R in 2008.

_R_e_f_e_r_e_n_c_e_s:

     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S
     Language_.  Wadsworth & Brooks/Cole.

     D. Goldberg (1991) _What Every Computer Scientist Should Know
     about Floating-Point Arithmetic_ ACM Computing Surveys, *23(1)*.
     Postscript version available at <URL:
     http://www.validlab.com/goldberg/paper.ps> Extended PDF version at
     <URL: http://www.validlab.com/goldberg/paper.pdf>

_S_e_e _A_l_s_o:

     ‘sqrt’ for miscellaneous and ‘Special’ for special mathematical
     functions.

     ‘Syntax’ for operator precedence.

     ‘%*%’ for matrix multiplication.

_E_x_a_m_p_l_e_s:

     x <- -1:12
     x + 1
     2 * x + 3
     x %% 2 #-- is periodic
     x %/% 5
     

> 
> ?women                  # information about data set "women"
women                 package:datasets                 R Documentation

_A_v_e_r_a_g_e _H_e_i_g_h_t_s _a_n_d _W_e_i_g_h_t_s _f_o_r _A_m_e_r_i_c_a_n _W_o_m_e_n

_D_e_s_c_r_i_p_t_i_o_n:

     This data set gives the average heights and weights for American
     women aged 30-39.

_U_s_a_g_e:

     women
     
_F_o_r_m_a_t:

     A data frame with 15 observations on 2 variables.

       ‘[,1]’  ‘height’  numeric  Height (in)  
       ‘[,2]’  ‘weight’  numeric  Weight (lbs) 
      
_D_e_t_a_i_l_s:

     The data set appears to have been taken from the American Society
     of Actuaries _Build and Blood Pressure Study_ for some (unknown to
     us) earlier year.

     The World Almanac notes: “The figures represent weights in
     ordinary indoor clothing and shoes, and heights with shoes”.

_S_o_u_r_c_e:

     The World Almanac and Book of Facts, 1975.

_R_e_f_e_r_e_n_c_e_s:

     McNeil, D. R. (1977) _Interactive Data Analysis_.  Wiley.

_E_x_a_m_p_l_e_s:

     require(graphics)
     plot(women, xlab = "Height (in)", ylab = "Weight (lb)",
          main = "women data: American women aged 30-39")
     

> 
> ## Not run: 
> ##D require(methods)
> ##D ## define a S4 generic function and some methods
> ##D combo <- function(x, y) c(x, y)
> ##D setGeneric("combo")
> ##D setMethod("combo", c("numeric", "numeric"), function(x, y) x+y)
> ##D 
> ##D ## assume we have written some documentation
> ##D ## for combo, and its methods ....
> ##D 
> ##D ?combo  # produces the function documentation
> ##D 
> ##D methods?combo  # looks for the overall methods documentation
> ##D 
> ##D method?combo("numeric", "numeric")  # documentation for the method above
> ##D 
> ##D ?combo(1:10, rnorm(10))  # ... the same method, selected according to
> ##D                          # the arguments (one integer, the other numeric)
> ##D 
> ##D ?combo(1:10, letters)    # documentation for the default method
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("RShowDoc")
> ### * RShowDoc
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: RShowDoc
> ### Title: Show R Manuals and Other Documentation
> ### Aliases: RShowDoc
> ### Keywords: documentation
> 
> ### ** Examples
> ## Not run: 
> ##D RShowDoc("R-lang")
> ##D RShowDoc("FAQ", type = "html")
> ##D RShowDoc("frame", package = "grid")
> ##D RShowDoc("changes.txt", package = "grid")
> ##D RShowDoc("NEWS", package = "MASS")
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("RSiteSearch")
> ### * RSiteSearch
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: RSiteSearch
> ### Title: Search for Key Words or Phrases in Documentation
> ### Aliases: RSiteSearch
> ### Keywords: utilities documentation
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("Rprof")
> ### * Rprof
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Rprof
> ### Title: Enable Profiling of R's Execution
> ### Aliases: Rprof
> ### Keywords: utilities
> 
> ### ** Examples
> 
> ## Not run: 
> ##D Rprof()
> ##D ## some code to be profiled
> ##D Rprof(NULL)
> ##D ## some code NOT to be profiled
> ##D Rprof(append = TRUE)
> ##D ## some code to be profiled
> ##D Rprof(NULL)
> ##D ...
> ##D ## Now post-process the output as described in Details
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("Rprofmem")
> ### * Rprofmem
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Rprofmem
> ### Title: Enable Profiling of R's Memory Use
> ### Aliases: Rprofmem
> ### Keywords: utilities
> 
> ### ** Examples
> ## Not run: 
> ##D ## not supported unless R is compiled to support it.
> ##D Rprofmem("Rprofmem.out", threshold = 1000)
> ##D example(glm)
> ##D Rprofmem(NULL)
> ##D noquote(readLines("Rprofmem.out", n = 5))
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("Rscript")
> ### * Rscript
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Rscript
> ### Title: Scripting Front-End for R
> ### Aliases: Rscript
> ### Keywords: utilities
> 
> ### ** Examples
> ## Not run: 
> ##D Rscript -e 'date()' -e 'format(Sys.time(), "%a %b %d %X %Y")'
> ##D 
> ##D ## example #! script for a Unix-alike
> ##D 
> ##D #! /path/to/Rscript --vanilla --default-packages=utils
> ##D args <- commandArgs(TRUE)
> ##D res <- try(install.packages(args))
> ##D if(inherits(res, "try-error")) q(status=1) else q()
> ##D 
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("SHLIB")
> ### * SHLIB
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: SHLIB
> ### Title: Build Shared Object/DLL for Dynamic Loading
> ### Aliases: SHLIB
> ### Keywords: utilities
> 
> ### ** Examples
> ## Not run: 
> ##D R CMD SHLIB -o mylib.so a.f b.f -L/opt/acml3.5.0/gnu64/lib -lacml
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("Sweave")
> ### * Sweave
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: Sweave
> ### Title: Automatic Generation of Reports
> ### Aliases: Sweave Stangle SweaveSyntaxLatex SweaveSyntaxNoweb
> ### Keywords: utilities
> 
> ### ** Examples
> 
> testfile <- system.file("Sweave", "Sweave-test-1.Rnw", package = "utils")
> 
> ## enforce par(ask = FALSE)
> options(device.ask.default = FALSE)
> 
> ## create a LaTeX file
> Sweave(testfile)
Writing to file Sweave-test-1.tex
Processing code chunks with options ...
 1 : keep.source print term verbatim (Sweave-test-1.Rnw:15)
 2 : keep.source term hide (Sweave-test-1.Rnw:17)
 3 : echo keep.source print term verbatim (Sweave-test-1.Rnw:22)
 4 : keep.source term verbatim (Sweave-test-1.Rnw:30)
 5 : echo keep.source term verbatim (Sweave-test-1.Rnw:45)
 6 : echo keep.source term verbatim pdf  (Sweave-test-1.Rnw:53)
 7 : echo keep.source term verbatim pdf  (Sweave-test-1.Rnw:63)

You can now run (pdf)latex on ‘Sweave-test-1.tex’
> 
> ## This can be compiled to PDF by
> ## tools::texi2pdf("Sweave-test-1.tex")
> ## or outside R by
> ## R CMD texi2pdf Sweave-test-1.tex
> ## which sets the appropriate TEXINPUTS path.
> ## create an R source file from the code chunks
> Stangle(testfile)
Writing to file Sweave-test-1.R 
> ## which can be sourced, e.g.
> source("Sweave-test-1.R")
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20
 [1]  0.91897737  0.78213630  0.07456498 -1.98935170  0.61982575 -0.05612874
 [7] -0.15579551 -1.47075238 -0.47815006  0.41794156  1.35867955 -0.10278773
[13]  0.38767161 -0.05380504 -1.37705956 -0.41499456 -0.39428995 -0.05931340
[19]  1.10002537  0.76317575

	One Sample t-test

data:  x
t = -0.0332, df = 19, p-value = 0.9739
alternative hypothesis: true mean is not equal to 0
95 percent confidence interval:
 -0.414283  0.401340
sample estimates:
   mean of x 
-0.006471519 

> 
> ## Don't show: 
> if(!interactive()) unlink("Sweave-test-1*")
> ## End Don't show
> 
> 
> 
> cleanEx()
> nameEx("SweaveSyntConv")
> ### * SweaveSyntConv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: SweaveSyntConv
> ### Title: Convert Sweave Syntax
> ### Aliases: SweaveSyntConv
> ### Keywords: utilities
> 
> ### ** Examples
> 
> testfile <- system.file("Sweave", "Sweave-test-1.Rnw", package = "utils")
> 
> ## convert the file to latex syntax
> SweaveSyntConv(testfile, SweaveSyntaxLatex)
Wrote file Sweave-test-1.Stex 
> 
> ## and run it through Sweave
> Sweave("Sweave-test-1.Stex")
Writing to file Sweave-test-1.tex
Processing code chunks with options ...
 1 : keep.source print term verbatim (Sweave-test-1.Stex:15)
 2 : keep.source term hide (Sweave-test-1.Stex:17)
 3 : echo keep.source print term verbatim (Sweave-test-1.Stex:22)
 4 : keep.source term verbatim (Sweave-test-1.Stex:30)
 5 : echo keep.source term verbatim (Sweave-test-1.Stex:45)
 6 : echo keep.source term verbatim pdf  (Sweave-test-1.Stex:53)
 7 : echo keep.source term verbatim pdf  (Sweave-test-1.Stex:63)

You can now run (pdf)latex on ‘Sweave-test-1.tex’
> 
> ## Don't show: 
> if(!interactive()) unlink("Sweave-test-1*")
> ## End Don't show
> 
> 
> 
> cleanEx()
> nameEx("URLencode")
> ### * URLencode
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: URLencode
> ### Title: Encode or Decode a (partial) URL
> ### Aliases: URLencode URLdecode
> ### Keywords: utilities
> 
> ### ** Examples
> 
> (y <- URLencode("a url with spaces and / and @"))
[1] "a%20url%20with%20spaces%20and%20/%20and%20@"
> URLdecode(y)
[1] "a url with spaces and / and @"
> (y <- URLencode("a url with spaces and / and @", reserved = TRUE))
[1] "a%20url%20with%20spaces%20and%20%2f%20and%20%40"
> URLdecode(y)
[1] "a url with spaces and / and @"
> URLdecode("ab%20cd")
[1] "ab cd"
> 
> 
> 
> cleanEx()
> nameEx("adist")
> ### * adist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: adist
> ### Title: Approximate String Distances
> ### Aliases: adist
> ### Keywords: character
> 
> ### ** Examples
> 
> ## Cf. http://en.wikipedia.org/wiki/Levenshtein_distance
> adist("kitten", "sitting")
     [,1]
[1,]    3
> ## To see the transformation counts for the Levenshtein distance:
> drop(attr(adist("kitten", "sitting", counts = TRUE), "counts"))
ins del sub 
  1   0   2 
> ## To see the transformation sequences:
> attr(adist(c("kitten", "sitting"), counts = TRUE), "trafos")
     [,1]      [,2]     
[1,] "MMMMMM"  "SMMMSMI"
[2,] "SMMMSMD" "MMMMMMM"
> 
> ## Cf. the examples for agrep:
> adist("lasy", "1 lazy 2")
     [,1]
[1,]    5
> ## For a "partial approximate match" (as used for agrep):
> adist("lasy", "1 lazy 2", partial = TRUE)
     [,1]
[1,]    1
> 
> 
> 
> cleanEx()
> nameEx("alarm")
> ### * alarm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: alarm
> ### Title: Alert the User
> ### Aliases: alarm
> ### Keywords: utilities
> 
> ### ** Examples
> 
> alarm()
> 
> 
> 
> cleanEx()
> nameEx("apropos")
> ### * apropos
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: apropos
> ### Title: Find Objects by (Partial) Name
> ### Aliases: apropos find
> ### Keywords: data documentation environment
> 
> ### ** Examples
> 
> require(stats)
> 
> ## Not run: apropos("lm")
> apropos("GLM")                      # more than a dozen
 [1] "anova.glm"            "anova.glmlist"        ".__C__anova.glm"     
 [4] ".__C__anova.glm.null" ".__C__glm"            ".__C__glm.null"      
 [7] "glm"                  "glm.control"          "glm.fit"             
[10] "model.frame.glm"      "predict.glm"          "print.glm"           
[13] "residuals.glm"        "rstandard.glm"        "rstudent.glm"        
[16] "summary.glm"         
> ## that may include internal objects starting '.__C__' if
> ## methods is attached
> apropos("GLM", ignore.case = FALSE) # not one
character(0)
> apropos("lq")
[1] "evalq"       "evalqOnLoad"
> 
> cor <- 1:pi
> find("cor")                         #> ".GlobalEnv"   "package:stats"
[1] ".GlobalEnv"    "package:stats"
> find("cor", numeric = TRUE)                     # numbers with these names
   .GlobalEnv package:stats 
            1             3 
> find("cor", numeric = TRUE, mode = "function")  # only the second one
package:stats 
            3 
> rm(cor)
> 
> ## Not run: apropos(".", mode="list")  # a long list
> 
> # need a DOUBLE backslash '\\' (in case you don't see it anymore)
> apropos("\\[")
 [1] "["                    "[<-"                  "[["                  
 [4] "[[<-"                 "[.AsIs"               "[<-.data.frame"      
 [7] "[.data.frame"         "[[<-.data.frame"      "[[.data.frame"       
[10] "[<-.Date"             "[.Date"               "[[.Date"             
[13] "[.difftime"           "[<-.factor"           "[.factor"            
[16] "[[<-.factor"          "[[.factor"            "[.hexmode"           
[19] "[.listof"             "[.noquote"            "[.numeric_version"   
[22] "[[<-.numeric_version" "[[.numeric_version"   "[.octmode"           
[25] "[<-.POSIXct"          "[.POSIXct"            "[[.POSIXct"          
[28] "[<-.POSIXlt"          "[.POSIXlt"            "[.simple.list"       
[31] ".__T__[:base"        
> 
> ## Not run: 
> ##D # everything ##D 
> ##D length(apropos("."))
> ##D 
> ##D # those starting with 'pr'
> ##D apropos("^pr")
> ##D 
> ##D # the 1-letter things
> ##D apropos("^.$")
> ##D # the 1-2-letter things
> ##D apropos("^..?$")
> ##D # the 2-to-4 letter things
> ##D apropos("^.{2,4}$")
> ##D 
> ##D # the 8-and-more letter things
> ##D apropos("^.{8,}$")
> ##D table(nchar(apropos("^.{8,}$")))
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("aregexec")
> ### * aregexec
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aregexec
> ### Title: Approximate String Match Positions
> ### Aliases: aregexec
> ### Keywords: character
> 
> ### ** Examples
> 
> ## Cf. the examples for agrep.
> x <- c("1 lazy", "1", "1 LAZY")
> aregexec("laysy", x, max.distance = 2)
[[1]]
[1] 3
attr(,"match.length")
[1] 4

[[2]]
[1] -1
attr(,"match.length")
[1] -1

[[3]]
[1] -1
attr(,"match.length")
[1] -1

> aregexec("(lay)(sy)", x, max.distance = 2)
[[1]]
[1] 3 3 5
attr(,"match.length")
[1] 4 2 2

[[2]]
[1] -1
attr(,"match.length")
[1] -1

[[3]]
[1] -1
attr(,"match.length")
[1] -1

> aregexec("(lay)(sy)", x, max.distance = 2, ignore.case = TRUE)
[[1]]
[1] 3 3 6
attr(,"match.length")
[1] 4 3 1

[[2]]
[1] -1
attr(,"match.length")
[1] -1

[[3]]
[1] 3 3 6
attr(,"match.length")
[1] 4 3 1

> m <- aregexec("(lay)(sy)", x, max.distance = 2)
> regmatches(x, m)
[[1]]
[1] "lazy" "la"   "zy"  

[[2]]
character(0)

[[3]]
character(0)

> 
> 
> 
> cleanEx()
> nameEx("aspell")
> ### * aspell
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aspell
> ### Title: Spell Check Interface
> ### Aliases: aspell
> ### Keywords: utilities
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## To check all Rd files in a directory, (additonally) skipping the
> ##D ## \references sections.
> ##D files <- Sys.glob("*.Rd")
> ##D aspell(files, filter = list("Rd", drop = "\references"))
> ##D 
> ##D ## To check all Sweave files
> ##D files <- Sys.glob(c("*.Rnw", "*.Snw", "*.rnw", "*.snw"))
> ##D aspell(files, filter = "Sweave", control = "-t")
> ##D 
> ##D ## To check all Texinfo files (Aspell only)
> ##D files <- Sys.glob("*.texi")
> ##D aspell(files, control = "--mode=texinfo")
> ## End(Not run)
> 
> ## List the available R system dictionaries.
> Sys.glob(file.path(R.home("share"), "dictionaries", "*.rds"))
[1] "/var/lib/stickshift/51915fc45973cabdbf00023c/app-root/data/R-3.0.0/share/dictionaries/en_stats.rds"
> 
> 
> 
> cleanEx()
> nameEx("available.packages")
> ### * available.packages
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: available.packages
> ### Title: List Available Packages at CRAN-like Repositories
> ### Aliases: available.packages
> ### Keywords: utilities
> 
> ### ** Examples
> ## Not run: 
> ##D ## restrict install.packages() (etc) to known-to-be-FOSS packages
> ##D options(available_packages_filters =
> ##D   c("R_version", "OS_type", "subarch", "duplicates", "license/FOSS"))
> ##D ## or
> ##D options(available_packages_filters = list(add = TRUE, "license/FOSS"))
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("bibentry")
> ### * bibentry
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: bibentry
> ### Title: Bibliography Entries
> ### Aliases: bibentry print.bibentry
> ### Keywords: utilities documentation
> 
> ### ** Examples
> 
> ## R reference
> rref <- bibentry(
+    bibtype = "Manual",
+    title = "R: A Language and Environment for Statistical Computing",
+    author = person("R Core Team"),
+    organization = "R Foundation for Statistical Computing",
+    address = "Vienna, Austria",
+    year = 2013,
+    url = "http://www.R-project.org/")
> 
> ## Different printing styles
> print(rref)
R Core Team (2013). _R: A Language and Environment for Statistical
Computing_. R Foundation for Statistical Computing, Vienna, Austria.
<URL: http://www.R-project.org/>.
> print(rref, style = "Bibtex")
@Manual{,
  title = {R: A Language and Environment for Statistical Computing},
  author = {{R Core Team}},
  organization = {R Foundation for Statistical Computing},
  address = {Vienna, Austria},
  year = {2013},
  url = {http://www.R-project.org/},
}
> print(rref, style = "citation")

R Core Team (2013). _R: A Language and Environment for Statistical
Computing_. R Foundation for Statistical Computing, Vienna, Austria.
<URL: http://www.R-project.org/>.

A BibTeX entry for LaTeX users is

  @Manual{,
    title = {R: A Language and Environment for Statistical Computing},
    author = {{R Core Team}},
    organization = {R Foundation for Statistical Computing},
    address = {Vienna, Austria},
    year = {2013},
    url = {http://www.R-project.org/},
  }

> print(rref, style = "html")
<p>R Core Team (2013).
<EM>R: A Language and Environment for Statistical Computing</EM>.
R Foundation for Statistical Computing, Vienna, Austria.
<a href="http://www.R-project.org/">http://www.R-project.org/</a>.
> print(rref, style = "latex")
R Core Team (2013).
\emph{R: A Language and Environment for Statistical Computing}.
R Foundation for Statistical Computing, Vienna, Austria.
\url{http://www.R-project.org/}.
> print(rref, style = "R")
bibentry(bibtype = "Manual",
         title = "R: A Language and Environment for Statistical Computing",
         author = person(given = "R Core Team"),
         organization = "R Foundation for Statistical Computing",
         address = "Vienna, Austria",
         year = "2013",
         url = "http://www.R-project.org/")
> 
> ## References for boot package and associated book
> bref <- c(
+    bibentry(
+      bibtype = "Manual",
+      title = "boot: Bootstrap R (S-PLUS) Functions",
+      author = c(
+        person("Angelo", "Canty", role = "aut",
+          comment = "S original"),
+        person(c("Brian", "D."), "Ripley", role = c("aut", "trl", "cre"),
+          comment = "R port, author of parallel support",
+          email = "ripley@stats.ox.ac.uk")
+      ),
+      year = "2012",
+      note = "R package version 1.3-4",
+      url = "http://CRAN.R-project.org/package=boot",
+      key = "boot-package"
+    ),
+ 
+    bibentry(
+      bibtype = "Book",
+      title = "Bootstrap Methods and Their Applications",
+      author = as.person("Anthony C. Davison [aut], David V. Hinkley [aut]"),
+      year = "1997",
+      publisher = "Cambridge University Press",
+      address = "Cambridge",
+      isbn = "0-521-57391-2",
+      url = "http://statwww.epfl.ch/davison/BMA/",
+      key = "boot-book"
+    )
+ )
> 
> ## Combining and subsetting
> c(rref, bref)
Canty A and Ripley BD (2012). _boot: Bootstrap R (S-PLUS) Functions_. R
package version 1.3-4, <URL: http://CRAN.R-project.org/package=boot>.

Davison AC and Hinkley DV (1997). _Bootstrap Methods and Their
Applications_. Cambridge University Press, Cambridge. ISBN
0-521-57391-2, <URL: http://statwww.epfl.ch/davison/BMA/>.

R Core Team (2013). _R: A Language and Environment for Statistical
Computing_. R Foundation for Statistical Computing, Vienna, Austria.
<URL: http://www.R-project.org/>.
> bref[2]
Davison AC and Hinkley DV (1997). _Bootstrap Methods and Their
Applications_. Cambridge University Press, Cambridge. ISBN
0-521-57391-2, <URL: http://statwww.epfl.ch/davison/BMA/>.
> bref["boot-book"]
Davison AC and Hinkley DV (1997). _Bootstrap Methods and Their
Applications_. Cambridge University Press, Cambridge. ISBN
0-521-57391-2, <URL: http://statwww.epfl.ch/davison/BMA/>.
> 
> ## Extracting fields
> bref$author
[[1]]
[1] "Angelo Canty [aut] (S original)"                                                             
[2] "Brian D. Ripley <ripley@stats.ox.ac.uk> [aut, trl, cre] (R port, author of parallel support)"

[[2]]
[1] "Anthony C. Davison [aut]" "David V. Hinkley [aut]"  

> bref[1]$author
[1] "Angelo Canty [aut] (S original)"                                                             
[2] "Brian D. Ripley <ripley@stats.ox.ac.uk> [aut, trl, cre] (R port, author of parallel support)"
> bref[1]$author[2]$email
[1] "ripley@stats.ox.ac.uk"
> 
> ## Convert to BibTeX
> toBibtex(bref)
@Manual{boot-package,
  title = {boot: Bootstrap R (S-PLUS) Functions},
  author = {Angelo Canty and Brian D. Ripley},
  year = {2012},
  note = {R package version 1.3-4},
  url = {http://CRAN.R-project.org/package=boot},
}

@Book{boot-book,
  title = {Bootstrap Methods and Their Applications},
  author = {Anthony C. Davison and David V. Hinkley},
  year = {1997},
  publisher = {Cambridge University Press},
  address = {Cambridge},
  isbn = {0-521-57391-2},
  url = {http://statwww.epfl.ch/davison/BMA/},
}
> 
> ## Format in R style
> ## One bibentry() call for each bibentry:
> writeLines(paste(format(bref, "R"), collapse = "\n\n"))
bibentry(bibtype = "Manual",
         key = "boot-package",
         title = "boot: Bootstrap R (S-PLUS) Functions",
         author = c(person(given = "Angelo",
                           family = "Canty",
                           role = "aut",
                           comment = "S original"),
                    person(given = c("Brian", "D."),
                           family = "Ripley",
                           role = c("aut", "trl", "cre"),
                           email = "ripley@stats.ox.ac.uk",
                           comment = "R port, author of parallel support")),
         year = "2012",
         note = "R package version 1.3-4",
         url = "http://CRAN.R-project.org/package=boot")

bibentry(bibtype = "Book",
         key = "boot-book",
         title = "Bootstrap Methods and Their Applications",
         author = c(person(given = c("Anthony", "C."),
                           family = "Davison",
                           role = "aut"),
                    person(given = c("David", "V."),
                           family = "Hinkley",
                           role = "aut")),
         year = "1997",
         publisher = "Cambridge University Press",
         address = "Cambridge",
         isbn = "0-521-57391-2",
         url = "http://statwww.epfl.ch/davison/BMA/")
> ## One collapsed call:
> writeLines(format(bref, "R", collapse = TRUE))
c(bibentry(bibtype = "Manual",
           key = "boot-package",
           title = "boot: Bootstrap R (S-PLUS) Functions",
           author = c(person(given = "Angelo",
                             family = "Canty",
                             role = "aut",
                             comment = "S original"),
                      person(given = c("Brian", "D."),
                             family = "Ripley",
                             role = c("aut", "trl", "cre"),
                             email = "ripley@stats.ox.ac.uk",
                             comment = "R port, author of parallel support")),
           year = "2012",
           note = "R package version 1.3-4",
           url = "http://CRAN.R-project.org/package=boot"),
  bibentry(bibtype = "Book",
           key = "boot-book",
           title = "Bootstrap Methods and Their Applications",
           author = c(person(given = c("Anthony", "C."),
                             family = "Davison",
                             role = "aut"),
                      person(given = c("David", "V."),
                             family = "Hinkley",
                             role = "aut")),
           year = "1997",
           publisher = "Cambridge University Press",
           address = "Cambridge",
           isbn = "0-521-57391-2",
           url = "http://statwww.epfl.ch/davison/BMA/"))
> 
> 
> 
> cleanEx()
> nameEx("browseEnv")
> ### * browseEnv
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: browseEnv
> ### Title: Browse Objects in Environment
> ### Aliases: browseEnv wsbrowser
> ### Keywords: interface
> 
> ### ** Examples
> 
> if(interactive()) {
+    ## create some interesting objects :
+    ofa <- ordered(4:1)
+    ex1 <- expression(1+ 0:9)
+    ex3 <- expression(u, v, 1+ 0:9)
+    example(factor, echo = FALSE)
+    example(table, echo = FALSE)
+    example(ftable, echo = FALSE)
+    example(lm, echo = FALSE, ask = FALSE)
+    example(str, echo = FALSE)
+ 
+    ## and browse them:
+    browseEnv()
+ 
+    ## a (simple) function's environment:
+    af12 <- approxfun(1:2, 1:2, method = "const")
+    browseEnv(envir = environment(af12))
+  }
> 
> 
> 
> cleanEx()
> nameEx("browseURL")
> ### * browseURL
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: browseURL
> ### Title: Load URL into a WWW Browser
> ### Aliases: browseURL
> ### Keywords: file
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## for KDE users who want to open files in a new tab
> ##D options(browser = "kfmclient newTab")
> ##D browseURL("http://www.r-project.org")
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("browseVignettes")
> ### * browseVignettes
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: browseVignettes
> ### Title: List Vignettes in an HTML Browser
> ### Aliases: browseVignettes print.browseVignettes
> ### Keywords: documentation
> 
> ### ** Examples
> ## Not run: 
> ##D ## List vignettes from all *attached* packages
> ##D browseVignettes(all = FALSE)
> ##D 
> ##D ## List vignettes from a specific package
> ##D browseVignettes("grid")
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("capture.output")
> ### * capture.output
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: capture.output
> ### Title: Send Output to a Character String or File
> ### Aliases: capture.output
> ### Keywords: utilities
> 
> ### ** Examples
> 
> require(stats)
> glmout <- capture.output(example(glm))
> glmout[1:5]
[1] ""                                                            
[2] "glm> ## Dobson (1990) Page 93: Randomized Controlled Trial :"
[3] "glm> counts <- c(18,17,15,20,10,20,25,13,12)"                
[4] ""                                                            
[5] "glm> outcome <- gl(3,1,9)"                                   
> capture.output(1+1, 2+2)
[1] "[1] 2" "[1] 4"
> capture.output({1+1; 2+2})
[1] "[1] 4"
> ## Not run: 
> ##D ## on Unix with enscript available
> ##D ps <- pipe("enscript -o tempout.ps","w")
> ##D capture.output(example(glm), file = ps)
> ##D close(ps)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("citation")
> ### * citation
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: citation
> ### Title: Citing R and R Packages in Publications
> ### Aliases: CITATION citation readCitationFile
> ### Keywords: misc
> 
> ### ** Examples
> 
> ## the basic R reference
> citation()

  R Core Team (2013). R: A language and environment for statistical
  computing. R Foundation for Statistical Computing, Vienna, Austria.
  URL http://www.R-project.org/.

A BibTeX entry for LaTeX users is

  @Manual{,
    title = {R: A Language and Environment for Statistical Computing},
    author = {{R Core Team}},
    organization = {R Foundation for Statistical Computing},
    address = {Vienna, Austria},
    year = {2013},
    url = {http://www.R-project.org/},
  }

> 
> ## references for a package -- might not have these installed
> if(nchar(system.file(package = "lattice"))) citation("lattice")

  Sarkar, Deepayan (2008) Lattice: Multivariate Data Visualization with
  R. Springer, New York. ISBN 978-0-387-75968-5

A BibTeX entry for LaTeX users is

  @Book{,
    title = {Lattice: Multivariate Data Visualization with R},
    author = {Deepayan Sarkar},
    publisher = {Springer},
    address = {New York},
    year = {2008},
    note = {ISBN 978-0-387-75968-5},
    url = {http://lmdvr.r-forge.r-project.org},
  }

> if(nchar(system.file(package = "foreign"))) citation("foreign")

To cite package ‘foreign’ in publications use:

  R Core Team (2013). foreign: Read Data Stored by Minitab, S, SAS,
  SPSS, Stata, Systat, dBase, .... R package version 0.8-53.
  http://CRAN.R-project.org/package=foreign

A BibTeX entry for LaTeX users is

  @Manual{,
    title = {foreign: Read Data Stored by Minitab, S, SAS, SPSS, Stata, Systat, dBase,
...},
    author = {{R Core Team}},
    year = {2013},
    note = {R package version 0.8-53},
    url = {http://CRAN.R-project.org/package=foreign},
  }

> 
> ## extract the bibtex entry from the return value
> x <- citation()
> toBibtex(x)
@Manual{,
  title = {R: A Language and Environment for Statistical Computing},
  author = {{R Core Team}},
  organization = {R Foundation for Statistical Computing},
  address = {Vienna, Austria},
  year = {2013},
  url = {http://www.R-project.org/},
}
> 
> 
> 
> cleanEx()
> nameEx("cite")
> ### * cite
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: cite
> ### Title: Cite a bibliography entry.
> ### Aliases: cite citeNatbib
> ### Keywords: utilities documentation
> 
> ### ** Examples
> 
> ## R reference
> rref <- bibentry(
+    bibtype = "Manual",
+    title = "R: A Language and Environment for Statistical Computing",
+    author = person("R Core Team"),
+    organization = "R Foundation for Statistical Computing",
+    address = "Vienna, Austria",
+    year = 2013,
+    url = "http://www.R-project.org/",
+    key = "R")
> 
> ## References for boot package and associated book
> bref <- c(
+    bibentry(
+      bibtype = "Manual",
+      title = "boot: Bootstrap R (S-PLUS) Functions",
+      author = c(
+        person("Angelo", "Canty", role = "aut",
+          comment = "S original"),
+        person(c("Brian", "D."), "Ripley", role = c("aut", "trl", "cre"),
+          comment = "R port, author of parallel support",
+          email = "ripley@stats.ox.ac.uk")
+      ),
+      year = "2012",
+      note = "R package version 1.3-4",
+      url = "http://CRAN.R-project.org/package=boot",
+      key = "boot-package"
+    ),
+ 
+    bibentry(
+      bibtype = "Book",
+      title = "Bootstrap Methods and Their Applications",
+      author = as.person("Anthony C. Davison [aut], David V. Hinkley [aut]"),
+      year = "1997",
+      publisher = "Cambridge University Press",
+      address = "Cambridge",
+      isbn = "0-521-57391-2",
+      url = "http://statwww.epfl.ch/davison/BMA/",
+      key = "boot-book"
+    )
+ )
> 
> ## Combine and cite
> refs <- c(rref, bref)
> cite("R, boot-package", refs)
[1] "(R Core Team 2013; Canty and Ripley 2012)"
> 
> ## Cite numerically
> savestyle <- tools::getBibstyle()
> tools::bibstyle("JSSnumbered", .init = TRUE,
+          fmtPrefix = function(paper) paste0("[", paper$.index, "]"),
+          cite = function(key, bib, ...)
+          	citeNatbib(key, bib, mode = "numbers",
+          	    bibpunct = c("[", "]", ";", "n", "", ","), ...)
+          )
<environment: 0x3b76530>
> cite("R, boot-package", refs, textual = TRUE)
[1] "R Core Team [3]; Canty and Ripley [1]"
> refs
[1] Canty A and Ripley BD (2012). _boot: Bootstrap R (S-PLUS)
Functions_. R package version 1.3-4, <URL:
http://CRAN.R-project.org/package=boot>.

[2] Davison AC and Hinkley DV (1997). _Bootstrap Methods and Their
Applications_. Cambridge University Press, Cambridge. ISBN
0-521-57391-2, <URL: http://statwww.epfl.ch/davison/BMA/>.

[3] R Core Team (2013). _R: A Language and Environment for Statistical
Computing_. R Foundation for Statistical Computing, Vienna, Austria.
<URL: http://www.R-project.org/>.
> 
> ## restore the old style
> tools::bibstyle(savestyle, .default = TRUE)
<environment: 0x37e2178>
> 
> 
> 
> cleanEx()
> nameEx("combn")
> ### * combn
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: combn
> ### Title: Generate All Combinations of n Elements, Taken m at a Time
> ### Aliases: combn
> ### Keywords: utilities iteration
> 
> ### ** Examples
> 
> combn(letters[1:4], 2)
     [,1] [,2] [,3] [,4] [,5] [,6]
[1,] "a"  "a"  "a"  "b"  "b"  "c" 
[2,] "b"  "c"  "d"  "c"  "d"  "d" 
> (m <- combn(10, 5, min))   # minimum value in each combination
  [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
 [38] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
 [75] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
[112] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
[149] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
[186] 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3
[223] 3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 5 5 5 5 5 6
> mm <- combn(15, 6, function(x) matrix(x, 2, 3))
> stopifnot(round(choose(10, 5)) == length(m),
+           c(2,3, round(choose(15, 6))) == dim(mm))
> 
> ## Different way of encoding points:
> combn(c(1,1,1,1,2,2,2,3,3,4), 3, tabulate, nbins = 4)
     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13] [,14]
[1,]    3    3    2    2    2    2    2    2    3     2     2     2     2     2
[2,]    0    0    1    1    1    0    0    0    0     1     1     1     0     0
[3,]    0    0    0    0    0    1    1    0    0     0     0     0     1     1
[4,]    0    0    0    0    0    0    0    1    0     0     0     0     0     0
     [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24] [,25] [,26]
[1,]     2     2     2     2     2     2     2     1     1     1     1     1
[2,]     0     1     1     1     0     0     0     2     2     1     1     1
[3,]     0     0     0     0     1     1     0     0     0     1     1     0
[4,]     1     0     0     0     0     0     1     0     0     0     0     1
     [,27] [,28] [,29] [,30] [,31] [,32] [,33] [,34] [,35] [,36] [,37] [,38]
[1,]     1     1     1     1     1     1     1     1     1     1     3     2
[2,]     2     1     1     1     1     1     1     0     0     0     0     1
[3,]     0     1     1     0     1     1     0     2     1     1     0     0
[4,]     0     0     0     1     0     0     1     0     1     1     0     0
     [,39] [,40] [,41] [,42] [,43] [,44] [,45] [,46] [,47] [,48] [,49] [,50]
[1,]     2     2     2     2     2     2     2     2     2     2     2     1
[2,]     1     1     0     0     0     1     1     1     0     0     0     2
[3,]     0     0     1     1     0     0     0     0     1     1     0     0
[4,]     0     0     0     0     1     0     0     0     0     0     1     0
     [,51] [,52] [,53] [,54] [,55] [,56] [,57] [,58] [,59] [,60] [,61] [,62]
[1,]     1     1     1     1     1     1     1     1     1     1     1     1
[2,]     2     1     1     1     2     1     1     1     1     1     1     0
[3,]     0     1     1     0     0     1     1     0     1     1     0     2
[4,]     0     0     0     1     0     0     0     1     0     0     1     0
     [,63] [,64] [,65] [,66] [,67] [,68] [,69] [,70] [,71] [,72] [,73] [,74]
[1,]     1     1     2     2     2     2     2     2     1     1     1     1
[2,]     0     0     1     1     1     0     0     0     2     2     1     1
[3,]     1     1     0     0     0     1     1     0     0     0     1     1
[4,]     1     1     0     0     0     0     0     1     0     0     0     0
     [,75] [,76] [,77] [,78] [,79] [,80] [,81] [,82] [,83] [,84] [,85] [,86]
[1,]     1     1     1     1     1     1     1     1     1     1     1     1
[2,]     1     2     1     1     1     1     1     1     0     0     0     2
[3,]     0     0     1     1     0     1     1     0     2     1     1     0
[4,]     1     0     0     0     1     0     0     1     0     1     1     0
     [,87] [,88] [,89] [,90] [,91] [,92] [,93] [,94] [,95] [,96] [,97] [,98]
[1,]     1     1     1     1     1     1     1     1     1     1     1     1
[2,]     2     1     1     1     2     1     1     1     1     1     1     0
[3,]     0     1     1     0     0     1     1     0     1     1     0     2
[4,]     0     0     0     1     0     0     0     1     0     0     1     0
     [,99] [,100] [,101] [,102] [,103] [,104] [,105] [,106] [,107] [,108]
[1,]     1      1      0      0      0      0      0      0      0      0
[2,]     0      0      3      2      2      2      2      2      2      1
[3,]     1      1      0      1      1      0      1      1      0      2
[4,]     1      1      0      0      0      1      0      0      1      0
     [,109] [,110] [,111] [,112] [,113] [,114] [,115] [,116] [,117] [,118]
[1,]      0      0      0      0      0      0      0      0      0      0
[2,]      1      1      2      2      2      1      1      1      1      1
[3,]      1      1      1      1      0      2      1      1      2      1
[4,]      1      1      0      0      1      0      1      1      0      1
     [,119] [,120]
[1,]      0      0
[2,]      1      0
[3,]      1      2
[4,]      1      1
> 
> ## Compute support points and (scaled) probabilities for a
> ## Multivariate-Hypergeometric(n = 3, N = c(4,3,2,1)) p.f.:
> # table.mat(t(combn(c(1,1,1,1,2,2,2,3,3,4), 3, tabulate, nbins = 4)))
> 
> ## Assuring the identity
> for(n in 1:7)
+  for(m in 0:n) stopifnot(is.array(cc <- combn(n, m)),
+                          dim(cc) == c(m, choose(n, m)))
> 
> 
> 
> cleanEx()
> nameEx("compareVersion")
> ### * compareVersion
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: compareVersion
> ### Title: Compare Two Package Version Numbers
> ### Aliases: compareVersion
> ### Keywords: utilities
> 
> ### ** Examples
> 
> compareVersion("1.0", "1.0-1")
[1] -1
> compareVersion("7.2-0","7.1-12")
[1] 1
> 
> 
> 
> cleanEx()
> nameEx("count.fields")
> ### * count.fields
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: count.fields
> ### Title: Count the Number of Fields per Line
> ### Aliases: count.fields
> ### Keywords: file
> 
> ### ** Examples
> 
> cat("NAME", "1:John", "2:Paul", file = "foo", sep = "\n")
> count.fields("foo", sep = ":")
[1] 1 2 2
> unlink("foo")
> 
> 
> 
> cleanEx()
> nameEx("data")
> ### * data
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: data
> ### Title: Data Sets
> ### Aliases: data print.packageIQR
> ### Keywords: documentation datasets
> 
> ### ** Examples
> 
> require(utils)
> data()                         # list all available data sets
Data sets in package ‘datasets’:

AirPassengers           Monthly Airline Passenger Numbers 1949-1960
BJsales                 Sales Data with Leading Indicator
BJsales.lead (BJsales)
                        Sales Data with Leading Indicator
BOD                     Biochemical Oxygen Demand
CO2                     Carbon Dioxide Uptake in Grass Plants
ChickWeight             Weight versus age of chicks on different diets
DNase                   Elisa assay of DNase
EuStockMarkets          Daily Closing Prices of Major European Stock
                        Indices, 1991-1998
Formaldehyde            Determination of Formaldehyde
HairEyeColor            Hair and Eye Color of Statistics Students
Harman23.cor            Harman Example 2.3
Harman74.cor            Harman Example 7.4
Indometh                Pharmacokinetics of Indomethacin
InsectSprays            Effectiveness of Insect Sprays
JohnsonJohnson          Quarterly Earnings per Johnson & Johnson Share
LakeHuron               Level of Lake Huron 1875-1972
LifeCycleSavings        Intercountry Life-Cycle Savings Data
Loblolly                Growth of Loblolly pine trees
Nile                    Flow of the River Nile
Orange                  Growth of Orange Trees
OrchardSprays           Potency of Orchard Sprays
PlantGrowth             Results from an Experiment on Plant Growth
Puromycin               Reaction Velocity of an Enzymatic Reaction
Seatbelts               Road Casualties in Great Britain 1969-84
Theoph                  Pharmacokinetics of Theophylline
Titanic                 Survival of passengers on the Titanic
ToothGrowth             The Effect of Vitamin C on Tooth Growth in
                        Guinea Pigs
UCBAdmissions           Student Admissions at UC Berkeley
UKDriverDeaths          Road Casualties in Great Britain 1969-84
UKgas                   UK Quarterly Gas Consumption
USAccDeaths             Accidental Deaths in the US 1973-1978
USArrests               Violent Crime Rates by US State
USJudgeRatings          Lawyers' Ratings of State Judges in the US
                        Superior Court
USPersonalExpenditure   Personal Expenditure Data
VADeaths                Death Rates in Virginia (1940)
WWWusage                Internet Usage per Minute
WorldPhones             The World's Telephones
ability.cov             Ability and Intelligence Tests
airmiles                Passenger Miles on Commercial US Airlines,
                        1937-1960
airquality              New York Air Quality Measurements
anscombe                Anscombe's Quartet of 'Identical' Simple Linear
                        Regressions
attenu                  The Joyner-Boore Attenuation Data
attitude                The Chatterjee-Price Attitude Data
austres                 Quarterly Time Series of the Number of
                        Australian Residents
beaver1 (beavers)       Body Temperature Series of Two Beavers
beaver2 (beavers)       Body Temperature Series of Two Beavers
cars                    Speed and Stopping Distances of Cars
chickwts                Chicken Weights by Feed Type
co2                     Mauna Loa Atmospheric CO2 Concentration
crimtab                 Student's 3000 Criminals Data
discoveries             Yearly Numbers of Important Discoveries
esoph                   Smoking, Alcohol and (O)esophageal Cancer
euro                    Conversion Rates of Euro Currencies
euro.cross (euro)       Conversion Rates of Euro Currencies
eurodist                Distances Between European Cities
faithful                Old Faithful Geyser Data
fdeaths (UKLungDeaths)
                        Monthly Deaths from Lung Diseases in the UK
freeny                  Freeny's Revenue Data
freeny.x (freeny)       Freeny's Revenue Data
freeny.y (freeny)       Freeny's Revenue Data
infert                  Infertility after Spontaneous and Induced
                        Abortion
iris                    Edgar Anderson's Iris Data
iris3                   Edgar Anderson's Iris Data
islands                 Areas of the World's Major Landmasses
ldeaths (UKLungDeaths)
                        Monthly Deaths from Lung Diseases in the UK
lh                      Luteinizing Hormone in Blood Samples
longley                 Longley's Economic Regression Data
lynx                    Annual Canadian Lynx trappings 1821-1934
mdeaths (UKLungDeaths)
                        Monthly Deaths from Lung Diseases in the UK
morley                  Michelson Speed of Light Data
mtcars                  Motor Trend Car Road Tests
nhtemp                  Average Yearly Temperatures in New Haven
nottem                  Average Monthly Temperatures at Nottingham,
                        1920-1939
occupationalStatus      Occupational Status of Fathers and their Sons
precip                  Annual Precipitation in US Cities
presidents              Quarterly Approval Ratings of US Presidents
pressure                Vapor Pressure of Mercury as a Function of
                        Temperature
quakes                  Locations of Earthquakes off Fiji
randu                   Random Numbers from Congruential Generator
                        RANDU
rivers                  Lengths of Major North American Rivers
rock                    Measurements on Petroleum Rock Samples
sleep                   Student's Sleep Data
stack.loss (stackloss)
                        Brownlee's Stack Loss Plant Data
stack.x (stackloss)     Brownlee's Stack Loss Plant Data
stackloss               Brownlee's Stack Loss Plant Data
state.abb (state)       US State Facts and Figures
state.area (state)      US State Facts and Figures
state.center (state)    US State Facts and Figures
state.division (state)
                        US State Facts and Figures
state.name (state)      US State Facts and Figures
state.region (state)    US State Facts and Figures
state.x77 (state)       US State Facts and Figures
sunspot.month           Monthly Sunspot Data, 1749-1997
sunspot.year            Yearly Sunspot Data, 1700-1988
sunspots                Monthly Sunspot Numbers, 1749-1983
swiss                   Swiss Fertility and Socioeconomic Indicators
                        (1888) Data
treering                Yearly Treering Data, -6000-1979
trees                   Girth, Height and Volume for Black Cherry Trees
uspop                   Populations Recorded by the US Census
volcano                 Topographic Information on Auckland's Maunga
                        Whau Volcano
warpbreaks              The Number of Breaks in Yarn during Weaving
women                   Average Heights and Weights for American Women


Use ‘data(package = .packages(all.available = TRUE))’
to list the data sets in all *available* packages.

> try(data(package = "rpart") )  # list the data sets in the rpart package
Data sets in package ‘rpart’:

car.test.frame          Automobile Data from 'Consumer Reports' 1990
car90                   Automobile Data from 'Consumer Reports' 1990
cu.summary              Automobile Data from 'Consumer Reports' 1990
kyphosis                Data on Children who have had Corrective Spinal
                        Surgery
solder                  Soldering of Components on Printed-Circuit
                        Boards
stagec                  Stage C Prostate Cancer

> data(USArrests, "VADeaths")    # load the data sets 'USArrests' and 'VADeaths'
> ## Not run: 
> ##D ## Alternatively
> ##D ds <- c("USArrests", "VADeaths"); data(list = ds)
> ## End(Not run)
> help(USArrests)                # give information on data set 'USArrests'
USArrests               package:datasets               R Documentation

_V_i_o_l_e_n_t _C_r_i_m_e _R_a_t_e_s _b_y _U_S _S_t_a_t_e

_D_e_s_c_r_i_p_t_i_o_n:

     This data set contains statistics, in arrests per 100,000
     residents for assault, murder, and rape in each of the 50 US
     states in 1973.  Also given is the percent of the population
     living in urban areas.

_U_s_a_g_e:

     USArrests
     
_F_o_r_m_a_t:

     A data frame with 50 observations on 4 variables.

       [,1]  Murder    numeric  Murder arrests (per 100,000)  
       [,2]  Assault   numeric  Assault arrests (per 100,000) 
       [,3]  UrbanPop  numeric  Percent urban population      
       [,4]  Rape      numeric  Rape arrests (per 100,000)    
      
_S_o_u_r_c_e:

     World Almanac and Book of facts 1975.  (Crime rates).

     Statistical Abstracts of the United States 1975.  (Urban rates).

_R_e_f_e_r_e_n_c_e_s:

     McNeil, D. R. (1977) _Interactive Data Analysis_.  New York:
     Wiley.

_S_e_e _A_l_s_o:

     The ‘state’ data sets.

_E_x_a_m_p_l_e_s:

     require(graphics)
     pairs(USArrests, panel = panel.smooth, main = "USArrests data")
     

> 
> 
> 
> cleanEx()
> nameEx("dataentry")
> ### * dataentry
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: dataentry
> ### Title: Spreadsheet Interface for Entering Data
> ### Aliases: data.entry dataentry de de.ncols de.restore de.setup
> ### Keywords: utilities file
> 
> ### ** Examples
> 
> # call data entry with variables x and y
> ## Not run: data.entry(x, y)
> 
> 
> 
> cleanEx()
> nameEx("debugger")
> ### * debugger
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: debugger
> ### Title: Post-Mortem Debugging
> ### Aliases: debugger dump.frames
> ### Keywords: utilities error
> 
> ### ** Examples
> 
> ## Not run: 
> ##D options(error = quote(dump.frames("testdump", TRUE)))
> ##D 
> ##D f <- function() {
> ##D     g <- function() stop("test dump.frames")
> ##D     g()
> ##D }
> ##D f()   # will generate a dump on file "testdump.rda"
> ##D options(error = NULL)
> ##D 
> ##D ## possibly in another R session
> ##D load("testdump.rda")
> ##D debugger(testdump)
> ##D Available environments had calls:
> ##D 1: f()
> ##D 2: g()
> ##D 3: stop("test dump.frames")
> ##D 
> ##D Enter an environment number, or 0 to exit
> ##D Selection: 1
> ##D Browsing in the environment with call:
> ##D f()
> ##D Called from: debugger.look(ind)
> ##D Browse[1]> ls()
> ##D [1] "g"
> ##D Browse[1]> g
> ##D function() stop("test dump.frames")
> ##D <environment: 759818>
> ##D Browse[1]>
> ##D Available environments had calls:
> ##D 1: f()
> ##D 2: g()
> ##D 3: stop("test dump.frames")
> ##D 
> ##D Enter an environment number, or 0 to exit
> ##D Selection: 0
> ##D 
> ##D ## A possible setting for non-interactive sessions
> ##D options(error = quote({dump.frames(to.file = TRUE); q()}))
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("demo")
> ### * demo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: demo
> ### Title: Demonstrations of R Functionality
> ### Aliases: demo
> ### Keywords: documentation utilities
> 
> ### ** Examples
> 
> demo() # for attached packages
Demos in package ‘base’:

error.catching          More examples on catching and handling errors
is.things               Explore some properties of R objects and
                        is.FOO() functions. Not for newbies!
recursion               Using recursion for adaptive integration
scoping                 An illustration of lexical scoping.

Demos in package ‘graphics’:

Hershey                 Tables of the characters in the Hershey vector
                        fonts
Japanese                Tables of the Japanese characters in the
                        Hershey vector fonts
graphics                A show of some of R's graphics capabilities
image                   The image-like graphics builtins of R
persp                   Extended persp() examples
plotmath                Examples of the use of mathematics annotation

Demos in package ‘grDevices’:

colors                  A show of R's predefined colors()
hclColors               Exploration of hcl() space

Demos in package ‘stats’:

glm.vr                  Some glm() examples from V&R with several
                        predictors
lm.glm                  Some linear and generalized linear modelling
                        examples from `An Introduction to Statistical
                        Modelling' by Annette Dobson
nlm                     Nonlinear least-squares using nlm()
smooth                  `Visualize' steps in Tukey's smoothers


Use ‘demo(package = .packages(all.available = TRUE))’
to list the demos in all *available* packages.

> 
> ## All available demos:
> demo(package = .packages(all.available = TRUE))
Demos in package ‘base’:

error.catching          More examples on catching and handling errors
is.things               Explore some properties of R objects and
                        is.FOO() functions. Not for newbies!
recursion               Using recursion for adaptive integration
scoping                 An illustration of lexical scoping.

Demos in package ‘graphics’:

Hershey                 Tables of the characters in the Hershey vector
                        fonts
Japanese                Tables of the Japanese characters in the
                        Hershey vector fonts
graphics                A show of some of R's graphics capabilities
image                   The image-like graphics builtins of R
persp                   Extended persp() examples
plotmath                Examples of the use of mathematics annotation

Demos in package ‘grDevices’:

colors                  A show of R's predefined colors()
hclColors               Exploration of hcl() space

Demos in package ‘lattice’:

intervals               Confidence intervals
labels                  Labels in lattice displays
lattice                 Lattice Demos
panel                   Custom panel functions

Demos in package ‘stats’:

glm.vr                  Some glm() examples from V&R with several
                        predictors
lm.glm                  Some linear and generalized linear modelling
                        examples from `An Introduction to Statistical
                        Modelling' by Annette Dobson
nlm                     Nonlinear least-squares using nlm()
smooth                  `Visualize' steps in Tukey's smoothers

Demos in package ‘tcltk’:

tkcanvas                Creates a canvas widget showing a 2-D plot with
                        data points that can be dragged with the mouse.
tkdensity               Interactive density plots.
tkfaq                   Show long file, the R FAQ, using scrollbared
                        window.
tkttest                 t-test example of GUI interface to a function
                        call.

> 
> 
> ## Not run: 
> ##D  ch <- "scoping"
> ##D  demo(ch, character = TRUE)
> ## End(Not run)
> 
> ## Find the location of a demo
> system.file("demo", "lm.glm.R", package = "stats")
[1] "/var/lib/stickshift/51915fc45973cabdbf00023c/app-root/data/R-3.0.0/library/stats/demo/lm.glm.R"
> 
> 
> 
> cleanEx()
> nameEx("edit")
> ### * edit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: edit
> ### Title: Invoke a Text Editor
> ### Aliases: edit edit.default vi emacs pico xemacs xedit
> ### Keywords: utilities
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # use xedit on the function mean and assign the changes
> ##D mean <- edit(mean, editor = "xedit")
> ##D 
> ##D # use vi on mean and write the result to file mean.out
> ##D vi(mean, file = "mean.out")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("edit.data.frame")
> ### * edit.data.frame
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: edit.data.frame
> ### Title: Edit Data Frames and Matrices
> ### Aliases: edit.data.frame edit.matrix
> ### Keywords: utilities
> 
> ### ** Examples
> 
> ## Not run: 
> ##D edit(InsectSprays)
> ##D edit(InsectSprays, factor.mode = "numeric")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("example")
> ### * example
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: example
> ### Title: Run an Examples Section from the Online Help
> ### Aliases: example
> ### Keywords: documentation utilities
> 
> ### ** Examples
> 
> example(InsectSprays)

InsctS> require(stats); require(graphics)

InsctS> boxplot(count ~ spray, data = InsectSprays,
InsctS+         xlab = "Type of spray", ylab = "Insect count",
InsctS+         main = "InsectSprays data", varwidth = TRUE, col = "lightgray")

InsctS> fm1 <- aov(count ~ spray, data = InsectSprays)

InsctS> summary(fm1)
            Df Sum Sq Mean Sq F value Pr(>F)    
spray        5   2669   533.8    34.7 <2e-16 ***
Residuals   66   1015    15.4                   
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

InsctS> opar <- par(mfrow = c(2, 2), oma = c(0, 0, 1.1, 0))

InsctS> plot(fm1)

InsctS> fm2 <- aov(sqrt(count) ~ spray, data = InsectSprays)

InsctS> summary(fm2)
            Df Sum Sq Mean Sq F value Pr(>F)    
spray        5  88.44  17.688    44.8 <2e-16 ***
Residuals   66  26.06   0.395                   
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

InsctS> plot(fm2)

InsctS> par(opar)
> ## force use of the standard package 'stats':
> example("smooth", package = "stats", lib.loc = .Library)

smooth> require(graphics)

smooth> ## see also   demo(smooth) !
smooth> 
smooth> x1 <- c(4, 1, 3, 6, 6, 4, 1, 6, 2, 4, 2) # very artificial

smooth> (x3R <- smooth(x1, "3R")) # 2 iterations of "3"
3R Tukey smoother resulting from  smooth(x = x1, kind = "3R") 
 used 2 iterations
 [1] 3 3 3 6 6 4 4 4 2 2 2

smooth> smooth(x3R, kind = "S")
S Tukey smoother resulting from  smooth(x = x3R, kind = "S") 
 changed
 [1] 3 3 3 3 4 4 4 4 2 2 2

smooth> sm.3RS <- function(x, ...)
smooth+    smooth(smooth(x, "3R", ...), "S", ...)

smooth> y <- c(1, 1, 19:1)

smooth> plot(y, main = "misbehaviour of \"3RSR\"", col.main = 3)

smooth> lines(sm.3RS(y))

smooth> lines(smooth(y))

smooth> lines(smooth(y, "3RSR"), col = 3, lwd = 2)  # the horror

smooth> x <- c(8:10, 10, 0, 0, 9, 9)

smooth> plot(x, main = "breakdown of  3R  and  S  and hence  3RSS")

smooth> matlines(cbind(smooth(x, "3R"), smooth(x, "S"), smooth(x, "3RSS"), smooth(x)))

smooth> presidents[is.na(presidents)] <- 0 # silly

smooth> summary(sm3 <- smooth(presidents, "3R"))
3R Tukey smoother resulting from
 smooth(x = presidents, kind = "3R") ;  n = 120 
 used 4 iterations
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
    0.0    44.0    57.0    54.2    71.0    82.0 

smooth> summary(sm2 <- smooth(presidents,"3RSS"))
3RSS Tukey smoother resulting from
 smooth(x = presidents, kind = "3RSS") ;  n = 120 
 used 5 iterations
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
   0.00   44.00   57.00   55.45   69.00   82.00 

smooth> summary(sm  <- smooth(presidents))
3RS3R Tukey smoother resulting from
 smooth(x = presidents) ;  n = 120 
 used 7 iterations
   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
  24.00   44.00   57.00   55.88   69.00   82.00 

smooth> all.equal(c(sm2), c(smooth(smooth(sm3, "S"), "S")))  # 3RSS  === 3R S S
[1] TRUE

smooth> all.equal(c(sm),  c(smooth(smooth(sm3, "S"), "3R"))) # 3RS3R === 3R S 3R
[1] TRUE

smooth> plot(presidents, main = "smooth(presidents0, *) :  3R and default 3RS3R")

smooth> lines(sm3, col = 3, lwd = 1.5)

smooth> lines(sm, col = 2, lwd = 1.25)
> 
> ## set RNG *before* example as when R CMD check is run:
> 
> r1 <- example(quantile, setRNG = TRUE)

quantl> quantile(x <- rnorm(1001)) # Extremes & Quartiles by default
         0%         25%         50%         75%        100% 
-3.00804860 -0.69731820 -0.03472603  0.68924373  3.81027668 

quantl> quantile(x,  probs = c(0.1, 0.5, 1, 2, 5, 10, 50, NA)/100)
       0.1%        0.5%          1%          2%          5%         10% 
-2.99694930 -2.59232767 -2.42431731 -2.24515257 -1.72663060 -1.33880074 
        50%             
-0.03472603          NA 

quantl> ### Compare different types
quantl> p <- c(0.1, 0.5, 1, 2, 5, 10, 50)/100

quantl> res <- matrix(as.numeric(NA), 9, 7)

quantl> for(type in 1:9) res[type, ] <- y <- quantile(x,  p, type = type)

quantl> dimnames(res) <- list(1:9, names(y))

quantl> round(res, 3)
    0.1%   0.5%     1%     2%     5%    10%    50%
1 -2.997 -2.592 -2.424 -2.245 -1.727 -1.339 -0.035
2 -2.997 -2.592 -2.424 -2.245 -1.727 -1.339 -0.035
3 -3.008 -2.596 -2.433 -2.265 -1.733 -1.344 -0.036
4 -3.008 -2.596 -2.433 -2.264 -1.733 -1.344 -0.035
5 -3.002 -2.594 -2.428 -2.255 -1.730 -1.341 -0.035
6 -3.008 -2.596 -2.432 -2.264 -1.733 -1.343 -0.035
7 -2.997 -2.592 -2.424 -2.245 -1.727 -1.339 -0.035
8 -3.004 -2.595 -2.430 -2.258 -1.731 -1.342 -0.035
9 -3.004 -2.595 -2.429 -2.257 -1.730 -1.341 -0.035
> x1 <- rnorm(1)
> u <- runif(1)
> ## identical random numbers
> r2 <- example(quantile, setRNG = TRUE)

quantl> quantile(x <- rnorm(1001)) # Extremes & Quartiles by default
         0%         25%         50%         75%        100% 
-3.00804860 -0.69731820 -0.03472603  0.68924373  3.81027668 

quantl> quantile(x,  probs = c(0.1, 0.5, 1, 2, 5, 10, 50, NA)/100)
       0.1%        0.5%          1%          2%          5%         10% 
-2.99694930 -2.59232767 -2.42431731 -2.24515257 -1.72663060 -1.33880074 
        50%             
-0.03472603          NA 

quantl> ### Compare different types
quantl> p <- c(0.1, 0.5, 1, 2, 5, 10, 50)/100

quantl> res <- matrix(as.numeric(NA), 9, 7)

quantl> for(type in 1:9) res[type, ] <- y <- quantile(x,  p, type = type)

quantl> dimnames(res) <- list(1:9, names(y))

quantl> round(res, 3)
    0.1%   0.5%     1%     2%     5%    10%    50%
1 -2.997 -2.592 -2.424 -2.245 -1.727 -1.339 -0.035
2 -2.997 -2.592 -2.424 -2.245 -1.727 -1.339 -0.035
3 -3.008 -2.596 -2.433 -2.265 -1.733 -1.344 -0.036
4 -3.008 -2.596 -2.433 -2.264 -1.733 -1.344 -0.035
5 -3.002 -2.594 -2.428 -2.255 -1.730 -1.341 -0.035
6 -3.008 -2.596 -2.432 -2.264 -1.733 -1.343 -0.035
7 -2.997 -2.592 -2.424 -2.245 -1.727 -1.339 -0.035
8 -3.004 -2.595 -2.430 -2.258 -1.731 -1.342 -0.035
9 -3.004 -2.595 -2.429 -2.257 -1.730 -1.341 -0.035
> x2 <- rnorm(1)
> stopifnot(identical(r1, r2))
> ## but x1 and x2 differ since the RNG state from before example()
> ## differs and is restored!
> x1; x2
[1] -0.6264538
[1] 1.329799
> 
> ## Exploring examples code:
> ## How large are the examples of "lm...()" functions?
> lmex <- sapply(apropos("^lm", mode = "function"),
+                example, character.only = TRUE, give.lines = TRUE)
> sapply(lmex, length)
          lm       lm.fit lm.influence      lm.wfit 
          33           21           18           21 
> 
> 
> 
> cleanEx()
> nameEx("file.edit")
> ### * file.edit
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: file.edit
> ### Title: Edit One or More Files
> ### Aliases: file.edit
> ### Keywords: utilities
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # open two R scripts for editing
> ##D file.edit("script1.R", "script2.R")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("filetest")
> ### * filetest
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: file_test
> ### Title: Shell-style Tests on Files
> ### Aliases: file_test
> ### Keywords: file
> 
> ### ** Examples
> 
> dir <- file.path(R.home(), "library", "stats")
> file_test("-d", dir)
[1] TRUE
> file_test("-nt", file.path(dir, "R"), file.path(dir, "demo"))
[1] TRUE
> 
> 
> 
> cleanEx()
> nameEx("findLineNum")
> ### * findLineNum
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: findLineNum
> ### Title: Find the Location of a Line of Source Code, or Set a Breakpoint
> ###   There.
> ### Aliases: findLineNum setBreakpoint
> ### Keywords: debugging
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Find what function was defined in the file mysource.R at line 100:
> ##D findLineNum("mysource.R#100")
> ##D 
> ##D # Set a breakpoint in both copies of that function, assuming one is in the
> ##D # same namespace as myfunction and the other is on the search path
> ##D setBreakpoint("mysource.R#100", envir = myfunction)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("fix")
> ### * fix
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: fix
> ### Title: Fix an Object
> ### Aliases: fix
> ### Keywords: utilities
> 
> ### ** Examples
> 
> ## Not run: 
> ##D  ## Assume 'my.fun' is a user defined function :
> ##D  fix(my.fun)
> ##D  ## now my.fun is changed
> ##D  ## Also,
> ##D  fix(my.data.frame) # calls up data editor
> ##D  fix(my.data.frame, factor.mode="char") # use of ...
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("format")
> ### * format
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: format
> ### Title: Format Unordered and Ordered Lists
> ### Aliases: formatUL formatOL
> ### Keywords: print
> 
> ### ** Examples
> 
> ## A simpler recipe.
> x <- c("Mix dry ingredients thoroughly.",
+        "Pour in wet ingredients.",
+        "Mix for 10 minutes.",
+        "Bake for one hour at 300 degrees.")
> ## Format and output as an unordered list.
> writeLines(formatUL(x))
* Mix dry ingredients thoroughly.
* Pour in wet ingredients.
* Mix for 10 minutes.
* Bake for one hour at 300 degrees.
> ## Format and output as an ordered list.
> writeLines(formatOL(x))
1. Mix dry ingredients thoroughly.
2. Pour in wet ingredients.
3. Mix for 10 minutes.
4. Bake for one hour at 300 degrees.
> ## Ordered list using lower case roman numerals.
> writeLines(formatOL(x, type = "i"))
  i. Mix dry ingredients thoroughly.
 ii. Pour in wet ingredients.
iii. Mix for 10 minutes.
 iv. Bake for one hour at 300 degrees.
> ## Ordered list using upper case letters and some offset.
> writeLines(formatOL(x, type = "A", offset = 5))
     A. Mix dry ingredients thoroughly.
     B. Pour in wet ingredients.
     C. Mix for 10 minutes.
     D. Bake for one hour at 300 degrees.
> 
> 
> 
> cleanEx()
> nameEx("getAnywhere")
> ### * getAnywhere
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getAnywhere
> ### Title: Retrieve an R Object, Including from a Namespace
> ### Aliases: getAnywhere argsAnywhere [.getAnywhere print.getAnywhere
> ### Keywords: data
> 
> ### ** Examples
> 
> getAnywhere("format.dist")
A single object matching ‘format.dist’ was found
It was found in the following places
  registered S3 method for format from namespace stats
  namespace:stats
with value

function (x, ...) 
format(as.vector(x), ...)
<bytecode: 0x481ed68>
<environment: namespace:stats>
> getAnywhere("simpleLoess") # not exported from stats
A single object matching ‘simpleLoess’ was found
It was found in the following places
  namespace:stats
with value

function (y, x, weights, span = 0.75, degree = 2L, parametric = FALSE, 
    drop.square = FALSE, normalize = TRUE, statistics = "approximate", 
    surface = "interpolate", cell = 0.2, iterations = 1L, trace.hat = "exact") 
{
    D <- as.integer(NCOL(x))
    if (is.na(D)) 
        stop("invalid NCOL(X)")
    if (D > 4) 
        stop("only 1-4 predictors are allowed")
    N <- as.integer(NROW(x))
    if (is.na(N)) 
        stop("invalid NCOL(X)")
    if (!N || !D) 
        stop("invalid 'x'")
    if (!length(y)) 
        stop("invalid 'y'")
    x <- as.matrix(x)
    storage.mode(x) <- "double"
    storage.mode(y) <- "double"
    storage.mode(weights) <- "double"
    max.kd <- max(N, 200)
    robust <- rep(1, N)
    divisor <- rep(1, D)
    if (normalize && D > 1L) {
        trim <- ceiling(0.1 * N)
        divisor <- sqrt(apply(apply(x, 2L, sort)[seq(trim + 1, 
            N - trim), , drop = FALSE], 2L, var))
        x <- x/rep(divisor, rep(N, D))
    }
    sum.drop.sqr <- sum(drop.square)
    sum.parametric <- sum(parametric)
    nonparametric <- sum(!parametric)
    order.parametric <- order(parametric)
    x <- x[, order.parametric]
    order.drop.sqr <- (2L - drop.square)[order.parametric]
    if (degree == 1L && sum.drop.sqr) 
        stop("specified the square of a factor predictor to be dropped when degree = 1")
    if (D == 1L && sum.drop.sqr) 
        stop("specified the square of a predictor to be dropped with only one numeric predictor")
    if (sum.parametric == D) 
        stop("specified parametric for all predictors")
    if (iterations) 
        for (j in seq_len(iterations)) {
            robust <- weights * robust
            if (j > 1) 
                statistics <- "none"
            else if (surface == "interpolate" && statistics == 
                "approximate") 
                statistics <- if (trace.hat == "exact") 
                  "1.approx"
                else "2.approx"
            surf.stat <- paste(surface, statistics, sep = "/")
            if (length(span) != 1L) 
                stop("invalid argument 'span'")
            if (length(cell) != 1L) 
                stop("invalid argument 'cell'")
            if (length(degree) != 1L) 
                stop("invalid argument 'degree'")
            z <- .C(C_loess_raw, y, x, weights, robust, D, N, 
                as.double(span), as.integer(degree), as.integer(nonparametric), 
                as.integer(order.drop.sqr), as.integer(sum.drop.sqr), 
                as.double(span * cell), as.character(surf.stat), 
                fitted.values = double(N), parameter = integer(7L), 
                a = integer(max.kd), xi = double(max.kd), vert = double(2L * 
                  D), vval = double((D + 1L) * max.kd), diagonal = double(N), 
                trL = double(1L), delta1 = double(1L), delta2 = double(1L), 
                as.integer(surf.stat == "interpolate/exact"))
            if (j == 1) {
                trace.hat.out <- z$trL
                one.delta <- z$delta1
                two.delta <- z$delta2
            }
            fitted.residuals <- y - z$fitted.values
            if (j < iterations) 
                robust <- .Fortran(C_lowesw, fitted.residuals, 
                  N, robust = double(N), integer(N))$robust
        }
    if (surface == "interpolate") {
        pars <- setNames(z$parameter, c("d", "n", "vc", "nc", 
            "nv", "liv", "lv"))
        enough <- (D + 1L) * pars["nv"]
        fit.kd <- list(parameter = pars, a = z$a[1L:pars[4L]], 
            xi = z$xi[1L:pars[4L]], vert = z$vert, vval = z$vval[1L:enough])
    }
    if (iterations > 1L) {
        pseudovalues <- .Fortran(C_lowesp, N, as.double(y), as.double(z$fitted.values), 
            as.double(weights), as.double(robust), integer(N), 
            pseudovalues = double(N))$pseudovalues
        zz <- .C(C_loess_raw, as.double(pseudovalues), x, weights, 
            weights, D, N, as.double(span), as.integer(degree), 
            as.integer(nonparametric), as.integer(order.drop.sqr), 
            as.integer(sum.drop.sqr), as.double(span * cell), 
            as.character(surf.stat), temp = double(N), parameter = integer(7L), 
            a = integer(max.kd), xi = double(max.kd), vert = double(2L * 
                D), vval = double((D + 1L) * max.kd), diagonal = double(N), 
            trL = double(1L), delta1 = double(1L), delta2 = double(1L), 
            0L)
        pseudo.resid <- pseudovalues - zz$temp
    }
    sum.squares <- if (iterations <= 1L) 
        sum(weights * fitted.residuals^2)
    else sum(weights * pseudo.resid^2)
    enp <- one.delta + 2 * trace.hat.out - N
    s <- sqrt(sum.squares/one.delta)
    pars <- list(robust = robust, span = span, degree = degree, 
        normalize = normalize, parametric = parametric, drop.square = drop.square, 
        surface = surface, cell = cell, family = if (iterations <= 
            1L) "gaussian" else "symmetric", iterations = iterations)
    fit <- list(n = N, fitted = z$fitted.values, residuals = fitted.residuals, 
        enp = enp, s = s, one.delta = one.delta, two.delta = two.delta, 
        trace.hat = trace.hat.out, divisor = divisor)
    fit$pars <- pars
    if (surface == "interpolate") 
        fit$kd <- fit.kd
    class(fit) <- "loess"
    fit
}
<bytecode: 0x4432be0>
<environment: namespace:stats>
> argsAnywhere(format.dist)
function (x, ...) 
NULL
> 
> 
> 
> cleanEx()
> nameEx("getFromNamespace")
> ### * getFromNamespace
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getFromNamespace
> ### Title: Utility functions for Developing Namespaces
> ### Aliases: assignInNamespace assignInMyNamespace getFromNamespace
> ###   fixInNamespace
> ### Keywords: data
> 
> ### ** Examples
> 
> getFromNamespace("findGeneric", "utils")
function (fname, envir) 
{
    if (!exists(fname, mode = "function", envir = envir)) 
        return("")
    f <- get(fname, mode = "function", envir = envir)
    if (.isMethodsDispatchOn() && methods::is(f, "genericFunction")) {
        fMethsEnv <- methods::getMethodsForDispatch(f)
        r <- lapply(grep("^ANY\\b", ls(envir = fMethsEnv), value = TRUE), 
            get, envir = fMethsEnv)
        if (any(ddm <- unlist(lapply(r, class)) == "derivedDefaultMethod")) 
            f <- r[ddm][[1]]@.Data
        else warning(gettextf("'%s' is a formal generic function; S3 methods will not likely be found", 
            fname), domain = NA)
    }
    isUMEbrace <- function(e) {
        for (ee in as.list(e[-1L])) if (nzchar(res <- isUME(ee))) 
            return(res)
        ""
    }
    isUMEif <- function(e) {
        if (length(e) == 3L) 
            isUME(e[[3L]])
        else {
            if (nzchar(res <- isUME(e[[3L]]))) 
                res
            else if (nzchar(res <- isUME(e[[4L]]))) 
                res
            else ""
        }
    }
    isUME <- function(e) {
        if (is.call(e) && (is.name(e[[1L]]) || is.character(e[[1L]]))) {
            switch(as.character(e[[1L]]), UseMethod = as.character(e[[2L]]), 
                `{` = isUMEbrace(e), `if` = isUMEif(e), "")
        }
        else ""
    }
    isUME(body(f))
}
<bytecode: 0x483a140>
<environment: namespace:utils>
> ## Not run: 
> ##D fixInNamespace("predict.ppr", "stats")
> ##D stats:::predict.ppr
> ##D getS3method("predict", "ppr")
> ##D ## alternatively
> ##D fixInNamespace("predict.ppr", pos = 3)
> ##D fixInNamespace("predict.ppr", pos = "package:stats")
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("getParseData")
> ### * getParseData
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getParseData
> ### Title: Get detailed parse information from object.
> ### Aliases: getParseData getParseText
> ### Keywords: utilities
> 
> ### ** Examples
> 
> fn <- function(x) {
+   x + 1 # A comment, kept as part of the source
+ }
> 
> d <- getParseData(fn)
> if (!is.null(d)) {
+   plus <- which(d$token == "'+'")
+   sum <- d$parent[plus]
+   print(d[as.character(sum),])
+   print(getParseText(d, sum))
+ }
> 
> 
> 
> cleanEx()
> nameEx("getS3method")
> ### * getS3method
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: getS3method
> ### Title: Get An S3 Method
> ### Aliases: getS3method
> ### Keywords: data
> 
> ### ** Examples
> 
> require(stats)
> exists("predict.ppr") # false
[1] FALSE
> getS3method("predict", "ppr")
function (object, newdata, ...) 
{
    if (missing(newdata)) 
        return(fitted(object))
    if (!is.null(object$terms)) {
        newdata <- as.data.frame(newdata)
        rn <- row.names(newdata)
        Terms <- delete.response(object$terms)
        m <- model.frame(Terms, newdata, na.action = na.omit, 
            xlev = object$xlevels)
        if (!is.null(cl <- attr(Terms, "dataClasses"))) 
            .checkMFClasses(cl, m)
        keep <- match(row.names(m), rn)
        x <- model.matrix(Terms, m, contrasts.arg = object$contrasts)
    }
    else {
        x <- as.matrix(newdata)
        keep <- seq_len(nrow(x))
        rn <- dimnames(x)[[1L]]
    }
    if (ncol(x) != object$p) 
        stop("wrong number of columns in 'x'")
    res <- matrix(NA, length(keep), object$q, dimnames = list(rn, 
        object$ynames))
    res[keep, ] <- matrix(.Fortran(C_pppred, as.integer(nrow(x)), 
        as.double(x), as.double(object$smod), y = double(nrow(x) * 
            object$q), double(2 * object$smod[4L]))$y, ncol = object$q)
    drop(res)
}
<bytecode: 0x483fc30>
<environment: namespace:stats>
> 
> 
> 
> cleanEx()
> nameEx("glob2rx")
> ### * glob2rx
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: glob2rx
> ### Title: Change Wildcard or Globbing Pattern into Regular Expression
> ### Aliases: glob2rx
> ### Keywords: file character utilities
> 
> ### ** Examples
> 
> stopifnot(glob2rx("abc.*") == "^abc\\.",
+           glob2rx("a?b.*") == "^a.b\\.",
+           glob2rx("a?b.*", trim.tail = FALSE) == "^a.b\\..*$",
+           glob2rx("*.doc") == "^.*\\.doc$",
+           glob2rx("*.doc", trim.head = TRUE) == "\\.doc$",
+           glob2rx("*.t*")  == "^.*\\.t",
+           glob2rx("*.t??") == "^.*\\.t..$",
+           glob2rx("*[*")  == "^.*\\["
+ )
> 
> 
> 
> cleanEx()
> nameEx("globalVariables")
> ### * globalVariables
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: globalVariables
> ### Title: Declare Variables to be Treated as Global in Checking a Package
> ### Aliases: globalVariables
> ### Keywords: packages
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## assume your package has some code that assigns ".obj1" and ".obj2"
> ##D ## but not in a way that codetools can find.
> ##D ## In the same source file (to remind you that you did it) add:
> ##D if(getRversion() >= "2.15.1")  utils::globalVariables(c(".obj1", "obj2"))
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("head")
> ### * head
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: head
> ### Title: Return the First or Last Part of an Object
> ### Aliases: head head.default head.data.frame head.function head.ftable
> ###   head.table head.matrix tail tail.default tail.data.frame
> ###   tail.function tail.ftable tail.table tail.matrix
> ### Keywords: manip
> 
> ### ** Examples
> 
> head(letters)
[1] "a" "b" "c" "d" "e" "f"
> head(letters, n = -6L)
 [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s"
[20] "t"
> 
> head(freeny.x, n = 10L)
      lag quarterly revenue price index income level market potential
 [1,]               8.79636     4.70997      5.82110          12.9699
 [2,]               8.79236     4.70217      5.82558          12.9733
 [3,]               8.79137     4.68944      5.83112          12.9774
 [4,]               8.81486     4.68558      5.84046          12.9806
 [5,]               8.81301     4.64019      5.85036          12.9831
 [6,]               8.90751     4.62553      5.86464          12.9854
 [7,]               8.93673     4.61991      5.87769          12.9900
 [8,]               8.96161     4.61654      5.89763          12.9943
 [9,]               8.96044     4.61407      5.92574          12.9992
[10,]               9.00868     4.60766      5.94232          13.0033
> head(freeny.y)
[1] 8.79236 8.79137 8.81486 8.81301 8.90751 8.93673
> 
> tail(letters)
[1] "u" "v" "w" "x" "y" "z"
> tail(letters, n = -6L)
 [1] "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s" "t" "u" "v" "w" "x" "y"
[20] "z"
> 
> tail(freeny.x)
      lag quarterly revenue price index income level market potential
[34,]               9.69405     4.30909      6.17369          13.1459
[35,]               9.69958     4.30909      6.16135          13.1520
[36,]               9.68683     4.30552      6.18231          13.1593
[37,]               9.71774     4.29627      6.18768          13.1579
[38,]               9.74924     4.27839      6.19377          13.1625
[39,]               9.77536     4.27789      6.20030          13.1664
> tail(freeny.y)
[1] 9.69958 9.68683 9.71774 9.74924 9.77536 9.79424
> 
> tail(library)
                                   
340         return(y)              
341     }                          
342     if (logical.return)        
343         TRUE                   
344     else invisible(.packages())
345 }                              
> 
> head(stats::ftable(Titanic))
                                               
                          "Survived" "No" "Yes"
 "Class" "Sex"    "Age"                        
 "1st"   "Male"   "Child"               0     5
                  "Adult"             118    57
         "Female" "Child"               0     1
                  "Adult"               4   140
 "2nd"   "Male"   "Child"               0    11
                  "Adult"             154    14
> 
> 
> 
> cleanEx()
> nameEx("help")
> ### * help
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: help
> ### Title: Documentation
> ### Aliases: help
> ### Keywords: documentation
> 
> ### ** Examples
> 
> help()
help                   package:utils                   R Documentation

_D_o_c_u_m_e_n_t_a_t_i_o_n

_D_e_s_c_r_i_p_t_i_o_n:

     ‘help’ is the primary interface to the help systems.

_U_s_a_g_e:

     help(topic, package = NULL, lib.loc = NULL,
          verbose = getOption("verbose"),
          try.all.packages = getOption("help.try.all.packages"),
          help_type = getOption("help_type"))
     
_A_r_g_u_m_e_n_t_s:

   topic: usually, a name or character string specifying the topic for
          which help is sought.  A character string (enclosed in
          explicit single or double quotes) is always taken as naming a
          topic.

          If the value of ‘topic’ is a length-one character vector the
          topic is taken to be the value of the only element.
          Otherwise ‘topic’ must be a name or a reserved word (if
          syntactically valid) or character string.

          See ‘Details’ for what happens if this is omitted.

 package: a name or character vector giving the packages to look into
          for documentation, or ‘NULL’.  By default, all packages in
          the search path are used.  To avoid a name being deparsed use
          e.g.  ‘(pkg_ref)’ (see the examples).

 lib.loc: a character vector of directory names of R libraries, or
          ‘NULL’.  The default value of ‘NULL’ corresponds to all
          libraries currently known.  If the default is used, the
          loaded packages are searched before the libraries.  This is
          not used for HTML help (see ‘Details’.

 verbose: logical; if ‘TRUE’, the file name is reported.

try.all.packages: logical; see ‘Note’.

help_type: character string: the type of help required.  Possible
          values are ‘"text"’, ‘"html"’ and ‘"pdf"’.  Case is ignored,
          and partial matching is allowed.

_D_e_t_a_i_l_s:

     The following types of help are available:

        • Plain text help

        • HTML help pages with hyperlinks to other topics, shown in a
          browser by ‘browseURL’.  (Where possible an existing browser
          window is re-used: the Mac OS X GUI uses its own browser
          window.)  If for some reason HTML help is unavailable (see
          ‘startDynamicHelp’), plain text help will be used instead.

        • For ‘help’ only, typeset as PDF - see the section on ‘Offline
          help’.

     The ‘factory-fresh’ default is text help except from the Mac OS
     GUI, which uses HTML help displayed in its own browser window.

     The rendering of text help will use directional quotes in suitable
     locales (UTF-8 and single-byte Windows locales): sometimes the
     fonts used do not support these quotes so this can be turned off
     by setting ‘options(useFancyQuotes = FALSE)’.

     ‘topic’ is not optional: if it is omitted R will give

        • If a package is specified, (text or, in interactive use only,
          HTML) information on the package, including hints/links to
          suitable help topics.

        • If ‘lib.loc’ only is specified, a (text) list of available
          packages.

        • Help on ‘help’ itself if none of the first three arguments is
          specified.

     Some topics need to be quoted (by backticks) or given as a
     character string.  These include those which cannot syntactically
     appear on their own such as unary and binary operators, ‘function’
     and control-flow reserved words (including ‘if’, ‘else’ ‘for’,
     ‘in’, ‘repeat’, ‘while’, ‘break’ and ‘next’).  The other
     ‘reserved’ words can be used as if they were names, for example
     ‘TRUE’, ‘NA’ and ‘Inf’.

     If multiple help files matching ‘topic’ are found, in interactive
     use a menu is presented for the user to choose one: in batch use
     the first on the search path is used.  (For HTML help the menu
     will be an HTML page, otherwise a graphical menu if possible if
     ‘getOption("menu.graphics")’ is true, the default.)

     Note that HTML help does not make use of ‘lib.loc’: it will always
     look first in the attached packages and then along ‘.libPaths()’.

_O_f_f_l_i_n_e _h_e_l_p:

     Typeset documentation is produced by running the LaTeX version of
     the help page through ‘pdflatex’: this will produce a PDF file.

     The appearance of the output can be customized through a file
     ‘Rhelp.cfg’ somewhere in your LaTeX search path: this will be
     input as a LaTeX style file after ‘Rd.sty’.  Some environment
     variables are consulted, notably ‘R_PAPERSIZE’ (_via_
     ‘getOption("papersize")’) and ‘R_RD4PDF’ (see ‘Making manuals’ in
     the ‘R Installation and Administration Manual’).

     If there is a function ‘offline_help_helper’ in the workspace or
     further down the search path it is used to do the typesetting,
     otherwise the function of that name in the ‘utils’ namespace (to
     which the first paragraph applies).  It should accept at least two
     arguments, the name of the LaTeX file to be typeset and the type
     (which as from R 2.15.0 is ignored).  As from R 2.14.0 it should
     accept a third argument, ‘texinputs’, which will give the graphics
     path when the help document contains figures, and will otherwise
     not be supplied.

_N_o_t_e:

     Unless ‘lib.loc’ is specified explicitly, the loaded packages are
     searched before those in the specified libraries.  This ensures
     that if a library is loaded from a library not in the known
     library trees, then the help from the loaded library is used.  If
     ‘lib.loc’ is specified explicitly, the loaded packages are _not_
     searched.

     If this search fails and argument ‘try.all.packages’ is ‘TRUE’ and
     neither ‘packages’ nor ‘lib.loc’ is specified, then all the
     packages in the known library trees are searched for help on
     ‘topic’ and a list of (any) packages where help may be found is
     displayed (with hyperlinks for ‘help_type = "html"’).  *NB:*
     searching all packages can be slow, especially the first time
     (caching of files by the OS can expedite subsequent searches
     dramatically).

_R_e_f_e_r_e_n_c_e_s:

     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S
     Language_.  Wadsworth & Brooks/Cole.

_S_e_e _A_l_s_o:

     ‘?’ for shortcuts to help topics.

     ‘help.search()’ or ‘??’ for finding help pages on a vague topic;
     ‘help.start()’ which opens the HTML version of the R help pages;
     ‘library()’ for listing available packages and the help objects
     they contain; ‘data()’ for listing available data sets;
     ‘methods()’.

     Use ‘prompt()’ to get a prototype for writing ‘help’ pages of your
     own package.

_E_x_a_m_p_l_e_s:

     help()
     help(help)              # the same
     
     help(lapply)
     
     help("for")             # or ?"for", but quotes/backticks are needed
     
     try({# requires working TeX installation:
      help(dgamma, help_type = "pdf")
      ## -> nicely formatted pdf -- including math formula -- for help(dgamma):
      system2(getOption("pdfviewer"), "dgamma.pdf", wait = FALSE)
     })
     
     help(package = "splines") # get help even when package is not loaded
     
     topi <- "women"
     help(topi)
     
     try(help("bs", try.all.packages = FALSE)) # reports not found (an error)
     help("bs", try.all.packages = TRUE)       # reports can be found
                                               # in package 'splines'
     
     ## For programmatic use:
     topic <- "family"; pkg_ref <- "stats"
     help((topic), (pkg_ref))
     

> help(help)              # the same
help                   package:utils                   R Documentation

_D_o_c_u_m_e_n_t_a_t_i_o_n

_D_e_s_c_r_i_p_t_i_o_n:

     ‘help’ is the primary interface to the help systems.

_U_s_a_g_e:

     help(topic, package = NULL, lib.loc = NULL,
          verbose = getOption("verbose"),
          try.all.packages = getOption("help.try.all.packages"),
          help_type = getOption("help_type"))
     
_A_r_g_u_m_e_n_t_s:

   topic: usually, a name or character string specifying the topic for
          which help is sought.  A character string (enclosed in
          explicit single or double quotes) is always taken as naming a
          topic.

          If the value of ‘topic’ is a length-one character vector the
          topic is taken to be the value of the only element.
          Otherwise ‘topic’ must be a name or a reserved word (if
          syntactically valid) or character string.

          See ‘Details’ for what happens if this is omitted.

 package: a name or character vector giving the packages to look into
          for documentation, or ‘NULL’.  By default, all packages in
          the search path are used.  To avoid a name being deparsed use
          e.g.  ‘(pkg_ref)’ (see the examples).

 lib.loc: a character vector of directory names of R libraries, or
          ‘NULL’.  The default value of ‘NULL’ corresponds to all
          libraries currently known.  If the default is used, the
          loaded packages are searched before the libraries.  This is
          not used for HTML help (see ‘Details’.

 verbose: logical; if ‘TRUE’, the file name is reported.

try.all.packages: logical; see ‘Note’.

help_type: character string: the type of help required.  Possible
          values are ‘"text"’, ‘"html"’ and ‘"pdf"’.  Case is ignored,
          and partial matching is allowed.

_D_e_t_a_i_l_s:

     The following types of help are available:

        • Plain text help

        • HTML help pages with hyperlinks to other topics, shown in a
          browser by ‘browseURL’.  (Where possible an existing browser
          window is re-used: the Mac OS X GUI uses its own browser
          window.)  If for some reason HTML help is unavailable (see
          ‘startDynamicHelp’), plain text help will be used instead.

        • For ‘help’ only, typeset as PDF - see the section on ‘Offline
          help’.

     The ‘factory-fresh’ default is text help except from the Mac OS
     GUI, which uses HTML help displayed in its own browser window.

     The rendering of text help will use directional quotes in suitable
     locales (UTF-8 and single-byte Windows locales): sometimes the
     fonts used do not support these quotes so this can be turned off
     by setting ‘options(useFancyQuotes = FALSE)’.

     ‘topic’ is not optional: if it is omitted R will give

        • If a package is specified, (text or, in interactive use only,
          HTML) information on the package, including hints/links to
          suitable help topics.

        • If ‘lib.loc’ only is specified, a (text) list of available
          packages.

        • Help on ‘help’ itself if none of the first three arguments is
          specified.

     Some topics need to be quoted (by backticks) or given as a
     character string.  These include those which cannot syntactically
     appear on their own such as unary and binary operators, ‘function’
     and control-flow reserved words (including ‘if’, ‘else’ ‘for’,
     ‘in’, ‘repeat’, ‘while’, ‘break’ and ‘next’).  The other
     ‘reserved’ words can be used as if they were names, for example
     ‘TRUE’, ‘NA’ and ‘Inf’.

     If multiple help files matching ‘topic’ are found, in interactive
     use a menu is presented for the user to choose one: in batch use
     the first on the search path is used.  (For HTML help the menu
     will be an HTML page, otherwise a graphical menu if possible if
     ‘getOption("menu.graphics")’ is true, the default.)

     Note that HTML help does not make use of ‘lib.loc’: it will always
     look first in the attached packages and then along ‘.libPaths()’.

_O_f_f_l_i_n_e _h_e_l_p:

     Typeset documentation is produced by running the LaTeX version of
     the help page through ‘pdflatex’: this will produce a PDF file.

     The appearance of the output can be customized through a file
     ‘Rhelp.cfg’ somewhere in your LaTeX search path: this will be
     input as a LaTeX style file after ‘Rd.sty’.  Some environment
     variables are consulted, notably ‘R_PAPERSIZE’ (_via_
     ‘getOption("papersize")’) and ‘R_RD4PDF’ (see ‘Making manuals’ in
     the ‘R Installation and Administration Manual’).

     If there is a function ‘offline_help_helper’ in the workspace or
     further down the search path it is used to do the typesetting,
     otherwise the function of that name in the ‘utils’ namespace (to
     which the first paragraph applies).  It should accept at least two
     arguments, the name of the LaTeX file to be typeset and the type
     (which as from R 2.15.0 is ignored).  As from R 2.14.0 it should
     accept a third argument, ‘texinputs’, which will give the graphics
     path when the help document contains figures, and will otherwise
     not be supplied.

_N_o_t_e:

     Unless ‘lib.loc’ is specified explicitly, the loaded packages are
     searched before those in the specified libraries.  This ensures
     that if a library is loaded from a library not in the known
     library trees, then the help from the loaded library is used.  If
     ‘lib.loc’ is specified explicitly, the loaded packages are _not_
     searched.

     If this search fails and argument ‘try.all.packages’ is ‘TRUE’ and
     neither ‘packages’ nor ‘lib.loc’ is specified, then all the
     packages in the known library trees are searched for help on
     ‘topic’ and a list of (any) packages where help may be found is
     displayed (with hyperlinks for ‘help_type = "html"’).  *NB:*
     searching all packages can be slow, especially the first time
     (caching of files by the OS can expedite subsequent searches
     dramatically).

_R_e_f_e_r_e_n_c_e_s:

     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S
     Language_.  Wadsworth & Brooks/Cole.

_S_e_e _A_l_s_o:

     ‘?’ for shortcuts to help topics.

     ‘help.search()’ or ‘??’ for finding help pages on a vague topic;
     ‘help.start()’ which opens the HTML version of the R help pages;
     ‘library()’ for listing available packages and the help objects
     they contain; ‘data()’ for listing available data sets;
     ‘methods()’.

     Use ‘prompt()’ to get a prototype for writing ‘help’ pages of your
     own package.

_E_x_a_m_p_l_e_s:

     help()
     help(help)              # the same
     
     help(lapply)
     
     help("for")             # or ?"for", but quotes/backticks are needed
     
     try({# requires working TeX installation:
      help(dgamma, help_type = "pdf")
      ## -> nicely formatted pdf -- including math formula -- for help(dgamma):
      system2(getOption("pdfviewer"), "dgamma.pdf", wait = FALSE)
     })
     
     help(package = "splines") # get help even when package is not loaded
     
     topi <- "women"
     help(topi)
     
     try(help("bs", try.all.packages = FALSE)) # reports not found (an error)
     help("bs", try.all.packages = TRUE)       # reports can be found
                                               # in package 'splines'
     
     ## For programmatic use:
     topic <- "family"; pkg_ref <- "stats"
     help((topic), (pkg_ref))
     

> 
> help(lapply)
lapply                  package:base                   R Documentation

_A_p_p_l_y _a _F_u_n_c_t_i_o_n _o_v_e_r _a _L_i_s_t _o_r _V_e_c_t_o_r

_D_e_s_c_r_i_p_t_i_o_n:

     ‘lapply’ returns a list of the same length as ‘X’, each element of
     which is the result of applying ‘FUN’ to the corresponding element
     of ‘X’.

     ‘sapply’ is a user-friendly version and wrapper of ‘lapply’ by
     default returning a vector, matrix or, if ‘simplify = "array"’, an
     array if appropriate, by applying ‘simplify2array()’.  ‘sapply(x,
     f, simplify = FALSE, USE.NAMES = FALSE)’ is the same as ‘lapply(x,
     f)’.

     ‘vapply’ is similar to ‘sapply’, but has a pre-specified type of
     return value, so it can be safer (and sometimes faster) to use.

     ‘replicate’ is a wrapper for the common use of ‘sapply’ for
     repeated evaluation of an expression (which will usually involve
     random number generation).

     ‘simplify2array()’ is the utility called from ‘sapply()’ when
     ‘simplify’ is not false and is similarly called from ‘mapply()’.

_U_s_a_g_e:

     lapply(X, FUN, ...)
     
     sapply(X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE)
     
     vapply(X, FUN, FUN.VALUE, ..., USE.NAMES = TRUE)
     
     replicate(n, expr, simplify = "array")
     
     simplify2array(x, higher = TRUE)
     
_A_r_g_u_m_e_n_t_s:

       X: a vector (atomic or list) or an ‘expression’ object.  Other
          objects (including classed objects) will be coerced by
          ‘base::as.list’.

     FUN: the function to be applied to each element of ‘X’: see
          ‘Details’.  In the case of functions like ‘+’, ‘%*%’, the
          function name must be backquoted or quoted.

     ...: optional arguments to ‘FUN’.

simplify: logical or character string; should the result be simplified
          to a vector, matrix or higher dimensional array if possible?
          For ‘sapply’ it must be named and not abbreviated.  The
          default value, ‘TRUE’, returns a vector or matrix if
          appropriate, whereas if ‘simplify = "array"’ the result may
          be an ‘array’ of “rank” (=‘length(dim(.))’) one higher than
          the result of ‘FUN(X[[i]])’.

USE.NAMES: logical; if ‘TRUE’ and if ‘X’ is character, use ‘X’ as
          ‘names’ for the result unless it had names already.  Since
          this argument follows ‘...’ its name cannot be abbreviated.

FUN.VALUE: a (generalized) vector; a template for the return value from
          FUN.  See ‘Details’.

       n: integer: the number of replications.

    expr: the expression (language object, usually a call) to evaluate
          repeatedly.

       x: a list, typically returned from ‘lapply()’.

  higher: logical; if true, ‘simplify2array()’ will produce a (“higher
          rank”) array when appropriate, whereas ‘higher = FALSE’ would
          return a matrix (or vector) only.  These two cases correspond
          to ‘sapply(*, simplify = "array")’ or ‘simplify = TRUE’,
          respectively.

_D_e_t_a_i_l_s:

     ‘FUN’ is found by a call to ‘match.fun’ and typically is specified
     as a function or a symbol (e.g. a backquoted name) or a character
     string specifying a function to be searched for from the
     environment of the call to ‘lapply’.

     Function ‘FUN’ must be able to accept as input any of the elements
     of ‘X’.  If the latter is an atomic vector, ‘FUN’ will always be
     passed a length-one vector of the same type as ‘X’.

     Arguments in ‘...’ cannot have the same name as any of the other
     arguments, and care may be needed to avoid partial matching to
     ‘FUN’.  In general-purpose code it is good practice to name the
     first two arguments ‘X’ and ‘FUN’ if ‘...’ is passed through: this
     both avoids partial matching to ‘FUN’ and ensures that a sensible
     error message is given if arguments named ‘X’ or ‘FUN’ are passed
     through ‘...’.

     Simplification in ‘sapply’ is only attempted if ‘X’ has length
     greater than zero and if the return values from all elements of
     ‘X’ are all of the same (positive) length.  If the common length
     is one the result is a vector, and if greater than one is a matrix
     with a column corresponding to each element of ‘X’.

     Simplification is always done in ‘vapply’.  This function checks
     that all values of ‘FUN’ are compatible with the ‘FUN.VALUE’, in
     that they must have the same length and type.  (Types may be
     promoted to a higher type within the ordering logical < integer <
     double < complex, but not demoted.)

     Users of S4 classes should pass a list to ‘lapply’ and ‘vapply’:
     the internal coercion is done by the ‘as.list’ in the base
     namespace and not one defined by a user (e.g. by setting S4
     methods on the base function).

     ‘lapply’ and ‘vapply’ are primitive functions.

_V_a_l_u_e:

     For ‘lapply’, ‘sapply(simplify = FALSE)’ and ‘replicate(simplify =
     FALSE)’, a list.

     For ‘sapply(simplify = TRUE)’ and ‘replicate(simplify = TRUE)’: if
     ‘X’ has length zero or ‘n = 0’, an empty list.  Otherwise an
     atomic vector or matrix or list of the same length as ‘X’ (of
     length ‘n’ for ‘replicate’).  If simplification occurs, the output
     type is determined from the highest type of the return values in
     the hierarchy NULL < raw < logical < integer < double < complex <
     character < list < expression, after coercion of pairlists to
     lists.

     ‘vapply’ returns a vector or array of type matching the
     ‘FUN.VALUE’.  If ‘length(FUN.VALUE) == 1’ a vector of the same
     length as ‘X’ is returned, otherwise an array.  If ‘FUN.VALUE’ is
     not an ‘array’, the result is a matrix with ‘length(FUN.VALUE)’
     rows and ‘length(X)’ columns, otherwise an array ‘a’ with ‘dim(a)
     == c(dim(FUN.VALUE), length(X))’.

     The (Dim)names of the array value are taken from the ‘FUN.VALUE’
     if it is named, otherwise from the result of the first function
     call.  Column names of the matrix or more generally the names of
     the last dimension of the array value or names of the vector value
     are set from ‘X’ as in ‘sapply’.

_N_o_t_e:

     ‘sapply(*, simplify = FALSE, USE.NAMES = FALSE)’ is equivalent to
     ‘lapply(*)’.

     For historical reasons, the calls created by ‘lapply’ are
     unevaluated, and code has been written (e.g. ‘bquote’) that relies
     on this.  This means that the recorded call is always of the form
     ‘FUN(X[[0L]], ...)’, with ‘0L’ replaced by the current integer
     index.  This is not normally a problem, but it can be if ‘FUN’
     uses ‘sys.call’ or ‘match.call’ or if it is a primitive function
     that makes use of the call.  This means that it is often safer to
     call primitive functions with a wrapper, so that e.g. ‘lapply(ll,
     function(x) is.numeric(x))’ is required in R 2.7.1 to ensure that
     method dispatch for ‘is.numeric’ occurs correctly.

     If ‘expr’ is a function call, be aware of assumptions about where
     it is evaluated, and in particular what ‘...’ might refer to.  You
     can pass additional named arguments to a function call as
     additional named arguments to ‘replicate’: see ‘Examples’.

_R_e_f_e_r_e_n_c_e_s:

     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S
     Language_.  Wadsworth & Brooks/Cole.

_S_e_e _A_l_s_o:

     ‘apply’, ‘tapply’, ‘mapply’ for applying a function to *m*ultiple
     arguments, and ‘rapply’ for a *r*ecursive version of ‘lapply()’,
     ‘eapply’ for applying a function to each entry in an
     ‘environment’.

_E_x_a_m_p_l_e_s:

     require(stats); require(graphics)
     
     x <- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE,FALSE,FALSE,TRUE))
     # compute the list mean for each list element
     lapply(x, mean)
     # median and quartiles for each list element
     lapply(x, quantile, probs = 1:3/4)
     sapply(x, quantile)
     i39 <- sapply(3:9, seq) # list of vectors
     sapply(i39, fivenum)
     vapply(i39, fivenum,
            c(Min. = 0, "1st Qu." = 0, Median = 0, "3rd Qu." = 0, Max. = 0))
     
     ## sapply(*, "array") -- artificial example
     (v <- structure(10*(5:8), names = LETTERS[1:4]))
     f2 <- function(x, y) outer(rep(x, length.out = 3), y)
     (a2 <- sapply(v, f2, y = 2*(1:5), simplify = "array"))
     a.2 <- vapply(v, f2, outer(1:3, 1:5), y = 2*(1:5))
     stopifnot(dim(a2) == c(3,5,4), all.equal(a2, a.2),
               identical(dimnames(a2), list(NULL,NULL,LETTERS[1:4])))
     
     hist(replicate(100, mean(rexp(10))))
     
     ## use of replicate() with parameters:
     foo <- function(x = 1, y = 2) c(x, y)
     # does not work: bar <- function(n, ...) replicate(n, foo(...))
     bar <- function(n, x) replicate(n, foo(x = x))
     bar(5, x = 3)
     

> 
> help("for")             # or ?"for", but quotes/backticks are needed
Control                  package:base                  R Documentation

_C_o_n_t_r_o_l _F_l_o_w

_D_e_s_c_r_i_p_t_i_o_n:

     These are the basic control-flow constructs of the R language.
     They function in much the same way as control statements in any
     Algol-like language.  They are all reserved words.

_U_s_a_g_e:

     if(cond) expr
     if(cond) cons.expr  else  alt.expr
     
     for(var in seq) expr
     while(cond) expr
     repeat expr
     break
     next
     
_A_r_g_u_m_e_n_t_s:

    cond: A length-one logical vector that is not ‘NA’.  Conditions of
          length greater than one are accepted with a warning, but only
          the first element is used.  Other types are coerced to
          logical if possible, ignoring any class.

     var: A syntactical name for a variable.

     seq: An expression evaluating to a vector (including a list and an
          expression) or to a pairlist or ‘NULL’.  A factor value will
          be coerced to a character vector.

expr, cons.expr, alt.expr: An _expression_ in a formal sense.  This is
          either a simple expression or a so called _compound
          expression_, usually of the form ‘{ expr1 ; expr2 }’.

_D_e_t_a_i_l_s:

     ‘break’ breaks out of a ‘for’, ‘while’ or ‘repeat’ loop; control
     is transferred to the first statement outside the inner-most loop.
     ‘next’ halts the processing of the current iteration and advances
     the looping index.  Both ‘break’ and ‘next’ apply only to the
     innermost of nested loops.

     Note that it is a common mistake to forget to put braces (‘{ ..
     }’) around your statements, e.g., after ‘if(..)’ or ‘for(....)’.
     In particular, you should not have a newline between ‘}’ and
     ‘else’ to avoid a syntax error in entering a ‘if ... else’
     construct at the keyboard or via ‘source’.  For that reason, one
     (somewhat extreme) attitude of defensive programming is to always
     use braces, e.g., for ‘if’ clauses.

     The ‘seq’ in a ‘for’ loop is evaluated at the start of the loop;
     changing it subsequently does not affect the loop.  If ‘seq’ has
     length zero the body of the loop is skipped. Otherwise the
     variable ‘var’ is assigned in turn the value of each element of
     ‘seq’. You can assign to ‘var’ within the body of the loop, but
     this will not affect the next iteration.  When the loop
     terminates, ‘var’ remains as a variable containing its latest
     value.

_V_a_l_u_e:

     ‘if’ returns the value of the expression evaluated, or ‘NULL’
     invisibly if none was (which may happen if there is no ‘else’).

     ‘for’, ‘while’ and ‘repeat’ return ‘NULL’ invisibly.  ‘for’ sets
     ‘var’ to the last used element of ‘seq’, or to ‘NULL’ if it was of
     length zero.

     ‘break’ and ‘next’ do not return a value as they transfer control
     within the loop.

_R_e_f_e_r_e_n_c_e_s:

     Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) _The New S
     Language_.  Wadsworth & Brooks/Cole.

_S_e_e _A_l_s_o:

     ‘Syntax’ for the basic R syntax and operators, ‘Paren’ for
     parentheses and braces.

     ‘ifelse’, ‘switch’ for other ways to control flow.

_E_x_a_m_p_l_e_s:

     for(i in 1:5) print(1:i)
     for(n in c(2,5,10,20,50)) {
        x <- stats::rnorm(n)
        cat(n, ": ", sum(x^2), "\n", sep = "")
     }
     f <- factor(sample(letters[1:5], 10, replace = TRUE))
     for(i in unique(f)) print(i)
     

> 
> 
> topi <- "women"
> help(topi)
women                 package:datasets                 R Documentation

_A_v_e_r_a_g_e _H_e_i_g_h_t_s _a_n_d _W_e_i_g_h_t_s _f_o_r _A_m_e_r_i_c_a_n _W_o_m_e_n

_D_e_s_c_r_i_p_t_i_o_n:

     This data set gives the average heights and weights for American
     women aged 30-39.

_U_s_a_g_e:

     women
     
_F_o_r_m_a_t:

     A data frame with 15 observations on 2 variables.

       ‘[,1]’  ‘height’  numeric  Height (in)  
       ‘[,2]’  ‘weight’  numeric  Weight (lbs) 
      
_D_e_t_a_i_l_s:

     The data set appears to have been taken from the American Society
     of Actuaries _Build and Blood Pressure Study_ for some (unknown to
     us) earlier year.

     The World Almanac notes: “The figures represent weights in
     ordinary indoor clothing and shoes, and heights with shoes”.

_S_o_u_r_c_e:

     The World Almanac and Book of Facts, 1975.

_R_e_f_e_r_e_n_c_e_s:

     McNeil, D. R. (1977) _Interactive Data Analysis_.  Wiley.

_E_x_a_m_p_l_e_s:

     require(graphics)
     plot(women, xlab = "Height (in)", ylab = "Weight (lb)",
          main = "women data: American women aged 30-39")
     

> 
> try(help("bs", try.all.packages = FALSE)) # reports not found (an error)
No documentation for ‘bs’ in specified packages and libraries:
you could try ‘??bs’
> help("bs", try.all.packages = TRUE)       # reports can be found
Help for topic ‘bs’ is not in any loaded package but can be found in
the following packages:

  Package               Library
  splines               /var/lib/stickshift/51915fc45973cabdbf00023c/app-root/data/R-3.0.0/library
>                                           # in package 'splines'
> 
> 
> 
> cleanEx()
> nameEx("help.search")
> ### * help.search
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: help.search
> ### Title: Search the Help System
> ### Aliases: help.search ?? print.hsearch
> ### Keywords: documentation
> 
> ### ** Examples
> 
> help.search("linear models")    # In case you forgot how to fit linear
Demos with name or title matching ‘linear models’ using fuzzy matching:


stats::lm.glm           Some linear and generalized linear modelling
                        examples from `An Introduction to Statistical
                        Modelling' by Annette Dobson


Type 'demo(PKG::FOO)' to run demonstration 'PKG::FOO'.



Help files with alias or concept or title matching ‘linear models’
using fuzzy matching:


boot::cv.glm            Cross-validation for Generalized Linear Models
boot::glm.diag          Generalized Linear Model Diagnostics
boot::glm.diag.plots    Diagnostics plots for generalized linear models
MASS::boxcox            Box-Cox Transformations for Linear Models
MASS::glm.nb            Fit a Negative Binomial Generalized Linear
                        Model
MASS::lm.gls            Fit Linear Models by Generalized Least Squares
MASS::loglm             Fit Log-Linear Models by Iterative Proportional
                        Scaling
MASS::loglm1            Fit Log-Linear Models by Iterative Proportional
                        Scaling - Internal function
MASS::rlm               Robust Fitting of Linear Models
MASS::stdres            Extract Standardized Residuals from a Linear
                        Model
MASS::studres           Extract Studentized Residuals from a Linear
                        Model
MASS::summary.rlm       Summary Method for Robust Linear Models
mgcv::bam               Generalized additive models for very large
                        datasets
mgcv::bam.update        Update a strictly additive bam model for new
                        data.
mgcv::gam               Generalized additive models with integrated
                        smoothness estimation
nlme::gls               Fit Linear Model Using Generalized Least
                        Squares
nlme::gnls              Fit Nonlinear Model Using Generalized Least
                        Squares
nlme::recalc            Recalculate Condensed Linear Model Object
nnet::multinom          Fit Multinomial Log-linear Models
stats::anova.glm        Analysis of Deviance for Generalized Linear
                        Model Fits
stats::anova.lm         ANOVA for Linear Model Fits
stats::anova.mlm        Comparisons between Multivariate Linear Models
stats::glm              Fitting Generalized Linear Models
stats::family.glm       Accessing Generalized Linear Model Fits
stats::lm.fit           Fitter Functions for Linear Models
stats::lm               Fitting Linear Models
stats::family.lm        Accessing Linear Model Fits
stats::loglin           Fitting Log-Linear Models
stats::predict.lm       Predict method for Linear Model Fits
stats::selfStart        Construct Self-starting Nonlinear Models
stats::summary.glm      Summarizing Generalized Linear Model Fits
stats::summary.lm       Summarizing Linear Model Fits


Type '?PKG::FOO' to inspect entries 'PKG::FOO', or 'TYPE?PKG::FOO' for
entries like 'PKG::FOO-TYPE'.




>                                 # models
> help.search("non-existent topic")
No vignettes or demos or help files found with alias or concept or
title matching ‘non-existent topic’ using fuzzy matching.
> 
> ??utils::help  # All the topics matching "help" in the utils package
Help files with alias or concept or title matching ‘help’ using regular
expression matching:


utils::example          Run an Examples Section from the Online Help
utils::help             Documentation
utils::help.request     Send a Post to R-help
utils::help.search      Search the Help System
utils::help.start       Hypertext Documentation


Type '?PKG::FOO' to inspect entries 'PKG::FOO', or 'TYPE?PKG::FOO' for
entries like 'PKG::FOO-TYPE'.




> 
> ## Not run: 
> ##D help.search("print")            # All help pages with topics or title
> ##D                                 # matching 'print'
> ##D help.search(apropos = "print")  # The same
> ##D 
> ##D help.search(keyword = "hplot")  # All help pages documenting high-level
> ##D                                 # plots.
> ##D file.show(file.path(R.home("doc"), "KEYWORDS"))  # show all keywords
> ##D 
> ##D ## Help pages with documented topics starting with 'try'.
> ##D help.search("\\btry", fields = "alias")
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("help.start")
> ### * help.start
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: help.start
> ### Title: Hypertext Documentation
> ### Aliases: help.start
> ### Keywords: documentation
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## the 'remote' arg can be tested by
> ##D help.start(remote = paste0("file://", R.home()))
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("install.packages")
> ### * install.packages
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: install.packages
> ### Title: Install Packages from Repositories or Local Files
> ### Aliases: install.packages
> ### Keywords: utilities
> 
> ### ** Examples
> ## Not run: 
> ##D ## A Linux example for Fedora's layout
> ##D install.packages(c("ncdf4", "RNetCDF"),
> ##D   configure.args = c(RNetCDF = "--with-netcdf-include=/usr/include/udunits2"))
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("installed.packages")
> ### * installed.packages
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: installed.packages
> ### Title: Find Installed Packages
> ### Aliases: installed.packages
> ### Keywords: utilities
> 
> ### ** Examples
> 
> ## confine search to .Library for speed
> str(ip <- installed.packages(.Library, priority = "high"))
 chr [1:29, 1:16] "base" "boot" "class" "cluster" "codetools" ...
 - attr(*, "dimnames")=List of 2
  ..$ : chr [1:29] "base" "boot" "class" "cluster" ...
  ..$ : chr [1:16] "Package" "LibPath" "Version" "Priority" ...
> ip[, c(1,3:5)]
           Package      Version   Priority     
base       "base"       "3.0.0"   "base"       
boot       "boot"       "1.3-9"   "recommended"
class      "class"      "7.3-7"   "recommended"
cluster    "cluster"    "1.14.4"  "recommended"
codetools  "codetools"  "0.2-8"   "recommended"
compiler   "compiler"   "3.0.0"   "base"       
datasets   "datasets"   "3.0.0"   "base"       
foreign    "foreign"    "0.8-53"  "recommended"
graphics   "graphics"   "3.0.0"   "base"       
grDevices  "grDevices"  "3.0.0"   "base"       
grid       "grid"       "3.0.0"   "base"       
KernSmooth "KernSmooth" "2.23-10" "recommended"
lattice    "lattice"    "0.20-15" "recommended"
MASS       "MASS"       "7.3-26"  "recommended"
Matrix     "Matrix"     "1.0-12"  "recommended"
methods    "methods"    "3.0.0"   "base"       
mgcv       "mgcv"       "1.7-22"  "recommended"
nlme       "nlme"       "3.1-109" "recommended"
nnet       "nnet"       "7.3-6"   "recommended"
parallel   "parallel"   "3.0.0"   "base"       
rpart      "rpart"      "4.1-1"   "recommended"
spatial    "spatial"    "7.3-6"   "recommended"
splines    "splines"    "3.0.0"   "base"       
stats      "stats"      "3.0.0"   "base"       
stats4     "stats4"     "3.0.0"   "base"       
survival   "survival"   "2.37-4"  "recommended"
tcltk      "tcltk"      "3.0.0"   "base"       
tools      "tools"      "3.0.0"   "base"       
utils      "utils"      "3.0.0"   "base"       
           Depends                                          
base       NA                                               
boot       "R (>= 3.0.0), graphics, stats"                  
class      "R (>= 3.0.0), stats, utils"                     
cluster    "R (>= 2.10.0), stats, graphics, utils"          
codetools  "R (>= 2.1)"                                     
compiler   NA                                               
datasets   NA                                               
foreign    "R (>= 2.14.0), stats"                           
graphics   NA                                               
grDevices  NA                                               
grid       NA                                               
KernSmooth "R (>= 2.5.0), stats"                            
lattice    "R (>= 2.15.1)"                                  
MASS       "R (>= 3.0.0), grDevices, graphics, stats, utils"
Matrix     "R (>= 2.15.0), stats, methods, utils, lattice"  
methods    NA                                               
mgcv       "R (>= 2.14.0), stats, graphics"                 
nlme       "graphics, stats, R (>= 3.0.0)"                  
nnet       "R (>= 2.14.0), stats, utils"                    
parallel   NA                                               
rpart      "R (>= 2.14.0), graphics, stats, grDevices"      
spatial    "R (>= 3.0.0), graphics, stats, utils"           
splines    NA                                               
stats      NA                                               
stats4     "methods, graphics, stats"                       
survival   "stats, utils, graphics, splines, R (>= 2.13.0)" 
tcltk      NA                                               
tools      NA                                               
utils      NA                                               
> plic <- installed.packages(.Library, priority = "high", fields = "License")
> ## what licenses are there:
> table( plic[, "License"] )

            GPL      GPL (>= 2)       GPL (>=2)   GPL-2 | GPL-3     LGPL (>= 2) 
              1               5               1               5               1 
Part of R 3.0.0       Unlimited 
             14               2 
> 
> 
> 
> cleanEx()
> nameEx("localeToCharset")
> ### * localeToCharset
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: localeToCharset
> ### Title: Select a Suitable Encoding Name from a Locale Name
> ### Aliases: localeToCharset
> ### Keywords: utilities
> 
> ### ** Examples
> 
> localeToCharset()
[1] "UTF-8"     "ISO8859-1"
> 
> 
> 
> cleanEx()
> nameEx("ls_str")
> ### * ls_str
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ls.str
> ### Title: List Objects and their Structure
> ### Aliases: ls.str lsf.str print.ls_str
> ### Keywords: print utilities
> 
> ### ** Examples
> 
> require(stats)
> 
> lsf.str()  #- how do the functions look like which I am using?
> ls.str(mode = "list")   #- what are the structured objects I have defined?
> 
> ## create a few objects
> example(glm, echo = FALSE)
  treatment outcome counts
1         1       1     18
2         1       2     17
3         1       3     15
4         2       1     20
5         2       2     10
6         2       3     20
7         3       1     25
8         3       2     13
9         3       3     12
> ll <- as.list(LETTERS)
> print(ls.str(), max.level = 0)# don't show details
anorex.1 : List of 30
anorexia : 'data.frame':	72 obs. of  3 variables:
clotting : 'data.frame':	9 obs. of  3 variables:
counts :  num [1:9] 18 17 15 20 10 20 25 13 12
d.AD : 'data.frame':	9 obs. of  3 variables:
glm.D93 : List of 30
ll : List of 26
outcome :  Factor w/ 3 levels "1","2","3": 1 2 3 1 2 3 1 2 3
treatment :  Factor w/ 3 levels "1","2","3": 1 1 1 2 2 2 3 3 3
> 
> ## which base functions have "file" in their name ?
> lsf.str(pos = length(search()), pattern = "file")
bzfile : function (description, open = "", encoding = getOption("encoding"), compression = 9)  
close.srcfile : function (con, ...)  
close.srcfilealias : function (con, ...)  
env.profile : function (env)  
file : function (description = "", open = "", blocking = TRUE, encoding = getOption("encoding"), 
    raw = FALSE)  
file.access : function (names, mode = 0)  
file.append : function (file1, file2)  
file.choose : function (new = FALSE)  
file.copy : function (from, to, overwrite = recursive, recursive = FALSE, copy.mode = TRUE)  
file.create : function (..., showWarnings = TRUE)  
file.exists : function (...)  
file.info : function (...)  
file.link : function (from, to)  
file.path : function (..., fsep = .Platform$file.sep)  
file.remove : function (...)  
file.rename : function (from, to)  
file.show : function (..., header = rep("", nfiles), title = "R Information", delete.file = FALSE, 
    pager = getOption("pager"), encoding = "")  
file.symlink : function (from, to)  
gzfile : function (description, open = "", encoding = getOption("encoding"), compression = 6)  
list.files : function (path = ".", pattern = NULL, all.files = FALSE, full.names = FALSE, 
    recursive = FALSE, ignore.case = FALSE, include.dirs = FALSE, no.. = FALSE)  
memory.profile : function ()  
open.srcfile : function (con, line, ...)  
open.srcfilealias : function (con, line, ...)  
open.srcfilecopy : function (con, line, ...)  
print.srcfile : function (x, ...)  
srcfile : function (filename, encoding = getOption("encoding"), Enc = "unknown")  
srcfilealias : function (filename, srcfile)  
srcfilecopy : function (filename, lines, timestamp = Sys.time(), isFile = FALSE)  
summary.srcfile : function (object, ...)  
system.file : function (..., package = "base", lib.loc = NULL, mustWork = FALSE)  
tempfile : function (pattern = "file", tmpdir = tempdir(), fileext = "")  
xzfile : function (description, open = "", encoding = getOption("encoding"), compression = 6)  
> 
> ## demonstrating that  ls.str() works inside functions
> ## ["browser/debug mode"]:
> tt <- function(x, y = 1) { aa <- 7; r <- x + y; ls.str() }
> (nms <- sapply(strsplit(capture.output(tt(2))," *: *"), `[`, 1))
[1] "aa" "r"  "x"  "y" 
> stopifnot(nms == c("aa", "r","x","y"))
> 
> 
> 
> cleanEx()
> nameEx("maintainer")
> ### * maintainer
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: maintainer
> ### Title: Show Package Maintainer
> ### Aliases: maintainer
> ### Keywords: utilities
> 
> ### ** Examples
> 
> maintainer("MASS")
[1] "Brian Ripley <ripley@stats.ox.ac.uk>"
> 
> 
> 
> cleanEx()
> nameEx("make.packages.html")
> ### * make.packages.html
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: make.packages.html
> ### Title: Update HTML Package List
> ### Aliases: make.packages.html
> ### Keywords: utilities
> 
> ### ** Examples
> ## Not run: 
> ##D make.packages.html()
> ##D # this can be slow for large numbers of installed packages.
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("make.socket")
> ### * make.socket
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: make.socket
> ### Title: Create a Socket Connection
> ### Aliases: make.socket print.socket
> ### Keywords: misc
> 
> ### ** Examples
> 
> daytime <- function(host = "localhost"){
+     a <- make.socket(host, 13)
+     on.exit(close.socket(a))
+     read.socket(a)
+ }
> ## Official time (UTC) from US Naval Observatory
> ## Not run: daytime("tick.usno.navy.mil")
> 
> 
> 
> cleanEx()
> nameEx("menu")
> ### * menu
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: menu
> ### Title: Menu Interaction Function
> ### Aliases: menu
> ### Keywords: utilities programming
> 
> ### ** Examples
> 
> ## Not run: 
> ##D switch(menu(c("List letters", "List LETTERS")) + 1,
> ##D        cat("Nothing done\n"), letters, LETTERS)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("methods")
> ### * methods
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: methods
> ### Title: List Methods for S3 Generic Functions or Classes
> ### Aliases: methods print.MethodsFunction
> ### Keywords: methods
> 
> ### ** Examples
> 
> require(stats)
> 
> methods(summary)
 [1] summary.aov             summary.aovlist         summary.aspell*        
 [4] summary.connection      summary.data.frame      summary.Date           
 [7] summary.default         summary.ecdf*           summary.factor         
[10] summary.glm             summary.infl            summary.lm             
[13] summary.loess*          summary.manova          summary.matrix         
[16] summary.mlm             summary.nls*            summary.packageStatus* 
[19] summary.PDF_Dictionary* summary.PDF_Stream*     summary.POSIXct        
[22] summary.POSIXlt         summary.ppr*            summary.prcomp*        
[25] summary.princomp*       summary.proc_time       summary.srcfile        
[28] summary.srcref          summary.stepfun         summary.stl*           
[31] summary.table           summary.tukeysmooth*   

   Non-visible functions are asterisked
> methods(class = "aov")
[1] coef.aov*         extractAIC.aov*   model.tables.aov* print.aov*       
[5] proj.aov*         se.contrast.aov*  summary.aov       TukeyHSD.aov     

   Non-visible functions are asterisked
> methods("[[")    # uses C-internal dispatching
[1] [[.bibentry*       [[.data.frame      [[.Date            [[.dendrogram*    
[5] [[.factor          [[.numeric_version [[.pdf_doc*        [[.person*        
[9] [[.POSIXct        

   Non-visible functions are asterisked
> methods("$")
[1] $.bibentry*       $.DLLInfo         $.package_version $.person*        

   Non-visible functions are asterisked
> methods("$<-")   # replacement function
[1] $<-.bibentry*  $<-.data.frame $<-.person*   

   Non-visible functions are asterisked
> methods("+")     # binary operator
[1] +.Date   +.POSIXt
> methods("Math")  # group generic
[1] Math.data.frame Math.Date       Math.difftime   Math.factor    
[5] Math.POSIXt    
> require(graphics)
> methods("axis")  # looks like it has methods, but not generic
Warning in methods("axis") : function 'axis' appears not to be generic
[1] axis.Date    axis.POSIXct
> ## Not run: 
> ##D methods(print)   # over 100
> ## End(Not run)
> ## --> help(showMethods) for related examples
> 
> 
> 
> cleanEx()
> nameEx("modifyList")
> ### * modifyList
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: modifyList
> ### Title: Recursively Modify Elements of a List
> ### Aliases: modifyList
> ### Keywords: utilities
> 
> ### ** Examples
> 
> foo <- list(a = 1, b = list(c = "a", d = FALSE))
> bar <- modifyList(foo, list(e = 2, b = list(d = TRUE)))
> str(foo)
List of 2
 $ a: num 1
 $ b:List of 2
  ..$ c: chr "a"
  ..$ d: logi FALSE
> str(bar)
List of 3
 $ a: num 1
 $ b:List of 2
  ..$ c: chr "a"
  ..$ d: logi TRUE
 $ e: num 2
> 
> 
> 
> cleanEx()
> nameEx("news")
> ### * news
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: news
> ### Title: Build and Query R or Package News Information
> ### Aliases: news
> 
> ### ** Examples
> 
> ## Build a db of all R news entries.
> db <- news()
> ## Don't show: 
>   vv <- capture.output(db)  # without an error
> ## End Don't show
> 
> 
> cleanEx()
> nameEx("nsl")
> ### * nsl
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: nsl
> ### Title: Look up the IP Address by Hostname
> ### Aliases: nsl
> ### Keywords: utilities
> 
> ### ** Examples
> 
> ## Not run: nsl("www.r-project.org")
> 
> 
> 
> cleanEx()
> nameEx("object.size")
> ### * object.size
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: object.size
> ### Title: Report the Space Allocated for an Object
> ### Aliases: object.size print.object_size
> ### Keywords: utilities
> 
> ### ** Examples
> 
> object.size(letters)
1496 bytes
> object.size(ls)
69872 bytes
> print(object.size(library), units = "auto")
1.1 Mb
> ## find the 10 largest objects in the base package
> z <- sapply(ls("package:base"), function(x)
+             object.size(get(x, envir = baseenv())))
> as.matrix(rev(sort(z))[1:10])
                      [,1]
loadNamespace      1348552
library            1159424
[<-.data.frame      952176
rbind.data.frame    589776
parseNamespaceFile  529952
source              521296
cut.POSIXt          473496
merge.data.frame    467928
cut.Date            461088
data.frame          446320
> 
> 
> 
> cleanEx()
> nameEx("package.skeleton")
> ### * package.skeleton
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: package.skeleton
> ### Title: Create a Skeleton for a New Source Package
> ### Aliases: package.skeleton
> ### Keywords: file utilities
> 
> ### ** Examples
> 
> require(stats)
> ## two functions and two "data sets" :
> f <- function(x, y) x+y
> g <- function(x, y) x-y
> d <- data.frame(a = 1, b = 2)
> e <- rnorm(1000)
> ## Don't show: 
>   owd <- getwd()
>   setwd(tempdir())
> ## End Don't show
> package.skeleton(list = c("f","g","d","e"), name = "mypkg")
Creating directories ...
Creating DESCRIPTION ...
Creating NAMESPACE ...
Creating Read-and-delete-me ...
Saving functions and data ...
Making help files ...
Done.
Further steps are described in './mypkg/Read-and-delete-me'.
> ## Don't show: 
>  setwd(owd) 
> ## End Don't show
> 
> 
> 
> cleanEx()
> nameEx("packageDescription")
> ### * packageDescription
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: packageDescription
> ### Title: Package Description
> ### Aliases: packageDescription packageVersion print.packageDescription
> ### Keywords: utilities
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("packageName")
> ### * packageName
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: packageName
> ### Title: Find package associated with an environment.
> ### Aliases: packageName
> ### Keywords: utilities
> 
> ### ** Examples
> 
> packageName()
NULL
> packageName(environment(mean))
[1] "base"
> 
> 
> 
> cleanEx()
> nameEx("packageStatus")
> ### * packageStatus
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: packageStatus
> ### Title: Package Management Tools
> ### Aliases: packageStatus print.packageStatus summary.packageStatus
> ###   update.packageStatus upgrade.packageStatus upgrade
> ### Keywords: utilities
> 
> ### ** Examples
> 
> ## Not run: 
> ##D x <- packageStatus()
> ##D print(x)
> ##D summary(x)
> ##D upgrade(x)
> ##D x <- update(x)
> ##D print(x)
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("page")
> ### * page
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: page
> ### Title: Invoke a Pager on an R Object
> ### Aliases: page
> ### Keywords: utilities
> 
> ### ** Examples
> ## Not run: 
> ##D ## four ways to look at the code of 'page'
> ##D page(page)             # as an object
> ##D page("page")           # a character string
> ##D v <- "page"; page(v)   # a length-one character vector
> ##D page(utils::page)      # a call
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("person")
> ### * person
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: person
> ### Title: Persons
> ### Aliases: person as.person as.person.default [.person $.person
> ###   as.character.person c.person format.person print.person
> ###   toBibtex.person personList as.personList as.personList.person
> ###   as.personList.default
> ### Keywords: misc
> 
> ### ** Examples
> 
> ## Create a person object directly ...
> p1 <- person("Karl", "Pearson", email = "pearson@stats.heaven")
> 
> ## ... or convert a string.
> p2 <- as.person("Ronald Aylmer Fisher")
> 
> ## Combining and subsetting.
> p <- c(p1, p2)
> p[1]
[1] "Karl Pearson <pearson@stats.heaven>"
> p[-1]
[1] "Ronald Aylmer Fisher"
> 
> ## Extracting fields.
> p$family
[[1]]
[1] "Pearson"

[[2]]
[1] "Fisher"

> p$email
[[1]]
[1] "pearson@stats.heaven"

[[2]]
NULL

> p[1]$email
[1] "pearson@stats.heaven"
> 
> ## Specifying package authors, example from "boot":
> ## AC is the first author [aut] who wrote the S original.
> ## BR is the second author [aut], who translated the code to R [trl],
> ## and maintains the package [cre].
> b <- c(person("Angelo", "Canty", role = "aut", comment =
+          "S original, http://statwww.epfl.ch/davison/BMA/library.html"),
+        person(c("Brian", "D."), "Ripley", role = c("aut", "trl", "cre"),
+               comment = "R port", email = "ripley@stats.ox.ac.uk")
+      )
> b
[1] "Angelo Canty [aut] (S original, http://statwww.epfl.ch/davison/BMA/library.html)"
[2] "Brian D. Ripley <ripley@stats.ox.ac.uk> [aut, trl, cre] (R port)"                
> 
> ## Formatting.
> format(b)
[1] "Angelo Canty [aut] (S original, http://statwww.epfl.ch/davison/BMA/library.html)"
[2] "Brian D. Ripley <ripley@stats.ox.ac.uk> [aut, trl, cre] (R port)"                
> format(b, include = c("family", "given", "role"),
+    braces = list(family = c("", ","), role = c("(Role(s): ", ")")))
[1] "Canty, Angelo (Role(s): aut)"             
[2] "Ripley, Brian D. (Role(s): aut, trl, cre)"
> 
> ## Conversion to BibTeX author field.
> paste(format(b, include = c("given", "family")), collapse = " and ")
[1] "Angelo Canty and Brian D. Ripley"
> toBibtex(b)
[1] "Angelo Canty and Brian D. Ripley"
> 
> 
> 
> cleanEx()
> nameEx("prompt")
> ### * prompt
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: prompt
> ### Title: Produce Prototype of an R Documentation File
> ### Aliases: prompt prompt.default prompt.data.frame
> ### Keywords: documentation
> 
> ### ** Examples
> 
> require(graphics)
> prompt(plot.default)
Created file named ‘plot.default.Rd’.
Edit the file and move it to the appropriate directory.
> prompt(interactive, force.function = TRUE)
Created file named ‘interactive.Rd’.
Edit the file and move it to the appropriate directory.
> unlink("plot.default.Rd")
> unlink("interactive.Rd")
> 
> prompt(women) # data.frame
Created file named ‘women.Rd’.
Edit the file and move it to the appropriate directory.
> unlink("women.Rd")
> 
> prompt(sunspots) # non-data.frame data
Created file named ‘sunspots.Rd’.
Edit the file and move it to the appropriate directory.
> unlink("sunspots.Rd")
> 
> ## Not run: 
> ##D ## Create a help file for each function in the .GlobalEnv:
> ##D for(f in ls()) if(is.function(get(f))) prompt(name = f)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("promptData")
> ### * promptData
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: promptData
> ### Title: Generate Outline Documentation for a Data Set
> ### Aliases: promptData
> ### Keywords: documentation
> 
> ### ** Examples
> 
> promptData(sunspots)
Created file named ‘sunspots.Rd’.
Edit the file and move it to the appropriate directory.
> unlink("sunspots.Rd")
> 
> 
> 
> cleanEx()
> nameEx("promptPackage")
> ### * promptPackage
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: promptPackage
> ### Title: Generate a Shell for Documentation of a Package
> ### Aliases: promptPackage
> ### Keywords: documentation
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("read.DIF")
> ### * read.DIF
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: read.DIF
> ### Title: Data Input from Spreadsheet
> ### Aliases: read.DIF
> ### Keywords: file connection
> 
> ### ** Examples
> 
> ## read.DIF() needs transpose = TRUE for file exported from Excel
> udir <- system.file("misc", package = "utils")
> dd <- read.DIF(file.path(udir, "exDIF.dif"), header = TRUE, transpose = TRUE)
> dc <- read.csv(file.path(udir, "exDIF.csv"), header = TRUE)
> stopifnot(identical(dd, dc), dim(dd) == c(4,2))
> 
> 
> 
> cleanEx()
> nameEx("read.fortran")
> ### * read.fortran
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: read.fortran
> ### Title: Read Fixed-Format Data
> ### Aliases: read.fortran
> ### Keywords: file connection
> 
> ### ** Examples
> 
> ff <- tempfile()
> cat(file = ff, "123456", "987654", sep = "\n")
> read.fortran(ff, c("F2.1","F2.0","I2"))
   V1 V2 V3
1 1.2 34 56
2 9.8 76 54
> read.fortran(ff, c("2F1.0","2X","2A1"))
  V1 V2 V3 V4
1  1  2  5  6
2  9  8  5  4
> unlink(ff)
> cat(file = ff, "123456AB", "987654CD", sep = "\n")
> read.fortran(ff, list(c("2F3.1","A2"), c("3I2","2X")))
    V1   V2 V3 V4 V5 V6
1 12.3 45.6 AB 98 76 54
> unlink(ff)
> # Note that the first number is read differently than Fortran would
> # read it:
> cat(file = ff, "12.3456", "1234567", sep = "\n")
> read.fortran(ff, "F7.4")
            V1
1   0.00123456
2 123.45670000
> unlink(ff)
> 
> 
> 
> cleanEx()
> nameEx("read.fwf")
> ### * read.fwf
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: read.fwf
> ### Title: Read Fixed Width Format Files
> ### Aliases: read.fwf
> ### Keywords: file connection
> 
> ### ** Examples
> 
> ff <- tempfile()
> cat(file = ff, "123456", "987654", sep = "\n")
> read.fwf(ff, widths = c(1,2,3))    #> 1 23 456 \ 9 87 654
  V1 V2  V3
1  1 23 456
2  9 87 654
> read.fwf(ff, widths = c(1,-2,3))   #> 1 456 \ 9 654
  V1  V2
1  1 456
2  9 654
> unlink(ff)
> cat(file = ff, "123", "987654", sep = "\n")
> read.fwf(ff, widths = c(1,0, 2,3))    #> 1 NA 23 NA \ 9 NA 87 654
  V1 V2 V3  V4
1  1 NA 23  NA
2  9 NA 87 654
> unlink(ff)
> cat(file = ff, "123456", "987654", sep = "\n")
> read.fwf(ff, widths = list(c(1,0, 2,3), c(2,2,2))) #> 1 NA 23 456 98 76 54
  V1 V2 V3  V4 V5 V6 V7
1  1 NA 23 456 98 76 54
> unlink(ff)
> 
> 
> 
> cleanEx()
> nameEx("read.socket")
> ### * read.socket
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: read.socket
> ### Title: Read from or Write to a Socket
> ### Aliases: read.socket write.socket
> ### Keywords: misc
> 
> ### ** Examples
> 
> finger <- function(user, host = "localhost", port = 79, print = TRUE)
+ {
+     if (!is.character(user))
+         stop("user name must be a string")
+     user <- paste(user,"\r\n")
+     socket <- make.socket(host, port)
+     on.exit(close.socket(socket))
+     write.socket(socket, user)
+     output <- character(0)
+     repeat{
+         ss <- read.socket(socket)
+         if (ss == "") break
+         output <- paste(output, ss)
+     }
+     close.socket(socket)
+     if (print) cat(output)
+     invisible(output)
+ }
> ## Not run: 
> ##D finger("root")  ## only works if your site provides a finger daemon
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("read.table")
> ### * read.table
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: read.table
> ### Title: Data Input
> ### Aliases: read.table read.csv read.csv2 read.delim read.delim2
> ### Keywords: file connection
> 
> ### ** Examples
> 
> ## using count.fields to handle unknown maximum number of fields
> ## when fill = TRUE
> test1 <- c(1:5, "6,7", "8,9,10")
> tf <- tempfile()
> writeLines(test1, tf)
> 
> read.csv(tf, fill = TRUE) # 1 column
  X1
1  2
2  3
3  4
4  5
5  6
6  7
7  8
8  9
9 10
> ncol <- max(count.fields(tf, sep = ","))
> read.csv(tf, fill = TRUE, header = FALSE,
+          col.names = paste0("V", seq_len(ncol)))
  V1 V2 V3
1  1 NA NA
2  2 NA NA
3  3 NA NA
4  4 NA NA
5  5 NA NA
6  6  7 NA
7  8  9 10
> unlink(tf)
> 
> ## "Inline" data set, using text=
> ## Notice that leading and trailing empty lines are auto-trimmed
> 
> read.table(header = TRUE, text = "
+ a b
+ 1 2
+ 3 4
+ ")
  a b
1 1 2
2 3 4
> 
> 
> 
> cleanEx()
> nameEx("recover")
> ### * recover
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: recover
> ### Title: Browsing after an Error
> ### Aliases: recover limitedLabels
> ### Keywords: programming debugging
> 
> ### ** Examples
> 
> ## Not run: 
> ##D 
> ##D options(error = recover) # setting the error option
> ##D 
> ##D ### Example of interaction
> ##D 
> ##D > myFit <- lm(y ~ x, data = xy, weights = w)
> ##D Error in lm.wfit(x, y, w, offset = offset, ...) :
> ##D         missing or negative weights not allowed
> ##D 
> ##D Enter a frame number, or 0 to exit
> ##D 1:lm(y ~ x, data = xy, weights = w)
> ##D 2:lm.wfit(x, y, w, offset = offset, ...)
> ##D Selection: 2
> ##D Called from: eval(expr, envir, enclos)
> ##D Browse[1]> objects() # all the objects in this frame
> ##D [1] "method" "n"      "ny"     "offset" "tol"    "w"
> ##D [7] "x"      "y"
> ##D Browse[1]> w
> ##D [1] -0.5013844  1.3112515  0.2939348 -0.8983705 -0.1538642
> ##D [6] -0.9772989  0.7888790 -0.1919154 -0.3026882
> ##D Browse[1]> dump.frames() # save for offline debugging
> ##D Browse[1]> c # exit the browser
> ##D 
> ##D Enter a frame number, or 0 to exit
> ##D 1:lm(y ~ x, data = xy, weights = w)
> ##D 2:lm.wfit(x, y, w, offset = offset, ...)
> ##D Selection: 0 # exit recover
> ##D >
> ##D 
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("relist")
> ### * relist
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: relist
> ### Title: Allow Re-Listing an unlist()ed Object
> ### Aliases: relist relist.default relist.list relist.factor relist.matrix
> ###   as.relistable is.relistable unlist.relistable
> ### Keywords: list manip
> 
> ### ** Examples
> 
>  ipar <- list(mean = c(0, 1), vcov = cbind(c(1, 1), c(1, 0)))
>  initial.param <- as.relistable(ipar)
>  ul <- unlist(initial.param)
>  relist(ul)
$mean
[1] 0 1

$vcov
     [,1] [,2]
[1,]    1    1
[2,]    1    0

attr(,"class")
[1] "relistable" "list"      
>  stopifnot(identical(relist(ul), initial.param))
> 
> 
> 
> cleanEx()
> nameEx("removeSource")
> ### * removeSource
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: removeSource
> ### Title: Remove Stored Source from a Function.
> ### Aliases: removeSource
> ### Keywords: utility
> 
> ### ** Examples
> 
> fn <- function(x) {
+   x + 1 # A comment, kept as part of the source
+ }
> fn
function (x) 
{
    x + 1
}
> fn <- removeSource(fn)
> fn
function (x) 
{
    x + 1
}
> 
> 
> 
> cleanEx()
> nameEx("roman")
> ### * roman
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: roman
> ### Title: Roman Numerals
> ### Aliases: as.roman
> ### Keywords: arith
> 
> ### ** Examples
> 
> ## First five roman 'numbers'.
> (y <- as.roman(1 : 5))
[1] I   II  III IV  V  
> ## Middle one.
> y[3]
[1] III
> ## Current year as a roman number.
> (y <- as.roman(format(Sys.Date(), "%Y")))
[1] MMXIII
> ## 10 years ago ...
> y - 10
[1] MMIII
> 
> 
> 
> cleanEx()
> nameEx("rtags")
> ### * rtags
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rtags
> ### Title: An Etags-like Tagging Utility for R
> ### Aliases: rtags
> ### Keywords: programming utilities
> 
> ### ** Examples
> 
> 
> ## Not run: 
> ##D rtags("/path/to/src/repository",
> ##D       pattern = "[.]*\\.[RrSs]$",
> ##D       keep.re = "/R/",
> ##D       verbose = TRUE,
> ##D       ofile = "TAGS",
> ##D       append = FALSE,
> ##D       recursive = TRUE)
> ## End(Not run)
> 
> 
> 
> 
> cleanEx()
> nameEx("savehistory")
> ### * savehistory
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: savehistory
> ### Title: Load or Save or Display the Commands History
> ### Aliases: loadhistory savehistory history timestamp
> ### Keywords: utilities
> 
> ### ** Examples
> ## Not run: 
> ##D ## save the history in the home directory: note that it is not
> ##D ## (by default) read from there.
> ##D .Last <- function()
> ##D     if(interactive()) try(savehistory("~/.Rhistory"))
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("select.list")
> ### * select.list
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: select.list
> ### Title: Select Items from a List
> ### Aliases: select.list
> ### Keywords: utilities
> 
> ### ** Examples
> ## Not run: 
> ##D select.list(sort(.packages(all.available = TRUE)))
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("sessionInfo")
> ### * sessionInfo
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sessionInfo
> ### Title: Collect Information About the Current R Session
> ### Aliases: sessionInfo toLatex.sessionInfo print.sessionInfo
> ### Keywords: misc
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("setRepositories")
> ### * setRepositories
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: setRepositories
> ### Title: Select Package Repositories
> ### Aliases: setRepositories
> ### Keywords: utilities
> 
> ### ** Examples
> ## Not run: 
> ##D setRepositories(addURLs =
> ##D                 c(CRANxtras = "http://www.stats.ox.ac.uk/pub/RWin"))
> ## End(Not run)
> 
> 
> cleanEx()
> nameEx("sourceutils")
> ### * sourceutils
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: sourceutils
> ### Title: Source Reference Utilities
> ### Aliases: getSrcFilename getSrcDirectory getSrcref getSrcLocation
> ### Keywords: utilities
> 
> ### ** Examples
> 
> fn <- function(x) {
+   x + 1 # A comment, kept as part of the source
+ }			
> 
> # Show the temporary file directory
> # where the example was saved
> 
> getSrcDirectory(fn)
character(0)
> getSrcLocation(fn, "line")
NULL
> 
> 
> 
> cleanEx()
> nameEx("stack")
> ### * stack
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: stack
> ### Title: Stack or Unstack Vectors from a Data Frame or List
> ### Aliases: stack stack.default stack.data.frame unstack unstack.default
> ###   unstack.data.frame
> ### Keywords: manip
> 
> ### ** Examples
> 
> require(stats)
> formula(PlantGrowth)         # check the default formula
weight ~ group
> pg <- unstack(PlantGrowth)   # unstack according to this formula
> pg
   ctrl trt1 trt2
1  4.17 4.81 6.31
2  5.58 4.17 5.12
3  5.18 4.41 5.54
4  6.11 3.59 5.50
5  4.50 5.87 5.37
6  4.61 3.83 5.29
7  5.17 6.03 4.92
8  4.53 4.89 6.15
9  5.33 4.32 5.80
10 5.14 4.69 5.26
> stack(pg)                    # now put it back together
   values  ind
1    4.17 ctrl
2    5.58 ctrl
3    5.18 ctrl
4    6.11 ctrl
5    4.50 ctrl
6    4.61 ctrl
7    5.17 ctrl
8    4.53 ctrl
9    5.33 ctrl
10   5.14 ctrl
11   4.81 trt1
12   4.17 trt1
13   4.41 trt1
14   3.59 trt1
15   5.87 trt1
16   3.83 trt1
17   6.03 trt1
18   4.89 trt1
19   4.32 trt1
20   4.69 trt1
21   6.31 trt2
22   5.12 trt2
23   5.54 trt2
24   5.50 trt2
25   5.37 trt2
26   5.29 trt2
27   4.92 trt2
28   6.15 trt2
29   5.80 trt2
30   5.26 trt2
> stack(pg, select = -ctrl)    # omitting one vector
   values  ind
1    4.81 trt1
2    4.17 trt1
3    4.41 trt1
4    3.59 trt1
5    5.87 trt1
6    3.83 trt1
7    6.03 trt1
8    4.89 trt1
9    4.32 trt1
10   4.69 trt1
11   6.31 trt2
12   5.12 trt2
13   5.54 trt2
14   5.50 trt2
15   5.37 trt2
16   5.29 trt2
17   4.92 trt2
18   6.15 trt2
19   5.80 trt2
20   5.26 trt2
> 
> 
> 
> cleanEx()
> nameEx("str")
> ### * str
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: str
> ### Title: Compactly Display the Structure of an Arbitrary R Object
> ### Aliases: str str.default str.data.frame strOptions
> ### Keywords: print documentation utilities
> 
> ### ** Examples
> 
> require(stats); require(grDevices); require(graphics)
> ## The following examples show some of 'str' capabilities
> str(1:12)
 int [1:12] 1 2 3 4 5 6 7 8 9 10 ...
> str(ls)
function (name, pos = -1L, envir = as.environment(pos), all.names = FALSE, 
    pattern)  
> str(args) #- more useful than  args(args) !
function (name)  
> str(freeny)
'data.frame':	39 obs. of  5 variables:
 $ y                    : Time-Series  from 1962 to 1972: 8.79 8.79 8.81 8.81 8.91 ...
 $ lag.quarterly.revenue: num  8.8 8.79 8.79 8.81 8.81 ...
 $ price.index          : num  4.71 4.7 4.69 4.69 4.64 ...
 $ income.level         : num  5.82 5.83 5.83 5.84 5.85 ...
 $ market.potential     : num  13 13 13 13 13 ...
> str(str)
function (object, ...)  
> str(.Machine, digits.d = 20) # extra digits for identification of binary numbers
List of 18
 $ double.eps           : num 2.2204460492503130808e-16
 $ double.neg.eps       : num 1.1102230246251565404e-16
 $ double.xmin          : num 2.2250738585072013831e-308
 $ double.xmax          : num 1.7976931348623157081e+308
 $ double.base          : int 2
 $ double.digits        : int 53
 $ double.rounding      : int 5
 $ double.guard         : int 0
 $ double.ulp.digits    : int -52
 $ double.neg.ulp.digits: int -53
 $ double.exponent      : int 11
 $ double.min.exp       : int -1022
 $ double.max.exp       : int 1024
 $ integer.max          : int 2147483647
 $ sizeof.long          : int 8
 $ sizeof.longlong      : int 8
 $ sizeof.longdouble    : int 16
 $ sizeof.pointer       : int 8
> str( lsfit(1:9, 1:9))
List of 4
 $ coefficients: Named num [1:2] 1.18e-15 1.00
  ..- attr(*, "names")= chr [1:2] "Intercept" "X"
 $ residuals   : num [1:9] -9.01e-16 1.72e-15 -2.47e-16 -2.25e-16 -2.03e-16 ...
 $ intercept   : logi TRUE
 $ qr          :List of 6
  ..$ qt   : num [1:9] -1.50e+01 7.75 -2.22e-16 0.00 2.22e-16 ...
  ..$ qr   : num [1:9, 1:2] -3 0.333 0.333 0.333 0.333 ...
  .. ..- attr(*, "dimnames")=List of 2
  .. .. ..$ : NULL
  .. .. ..$ : chr [1:2] "Intercept" "X"
  ..$ qraux: num [1:2] 1.33 1.26
  ..$ rank : int 2
  ..$ pivot: int [1:2] 1 2
  ..$ tol  : num 1e-07
  ..- attr(*, "class")= chr "qr"
> str( lsfit(1:9, 1:9), max.level = 1)
List of 4
 $ coefficients: Named num [1:2] 1.18e-15 1.00
  ..- attr(*, "names")= chr [1:2] "Intercept" "X"
 $ residuals   : num [1:9] -9.01e-16 1.72e-15 -2.47e-16 -2.25e-16 -2.03e-16 ...
 $ intercept   : logi TRUE
 $ qr          :List of 6
  ..- attr(*, "class")= chr "qr"
> str( lsfit(1:9, 1:9), width = 60, strict.width = "cut")
List of 4
 $ coefficients: Named num [1:2] 1.18e-15 1.00
  ..- attr(*, "names")= chr [1:2] "Intercept" "X"
 $ residuals   : num [1:9] -9.01e-16 1.72e-15 -2.47e-16 -2..
 $ intercept   : logi TRUE
 $ qr          :List of 6
  ..$ qt   : num [1:9] -1.50e+01 7.75 -2.22e-16 0.00 2.22e..
  ..$ qr   : num [1:9, 1:2] -3 0.333 0.333 0.333 0.333 ...
  .. ..- attr(*, "dimnames")=List of 2
  .. .. ..$ : NULL
  .. .. ..$ : chr [1:2] "Intercept" "X"
  ..$ qraux: num [1:2] 1.33 1.26
  ..$ rank : int 2
  ..$ pivot: int [1:2] 1 2
  ..$ tol  : num 1e-07
  ..- attr(*, "class")= chr "qr"
> str( lsfit(1:9, 1:9), width = 60, strict.width = "wrap")
List of 4
$ coefficients: Named num [1:2] 1.18e-15 1.00
..- attr(*, "names")= chr [1:2] "Intercept" "X"
$ residuals : num [1:9] -9.01e-16 1.72e-15 -2.47e-16
   -2.25e-16 -2.03e-16 ...
$ intercept : logi TRUE
$ qr :List of 6
..$ qt : num [1:9] -1.50e+01 7.75 -2.22e-16 0.00 2.22e-16
   ...
..$ qr : num [1:9, 1:2] -3 0.333 0.333 0.333 0.333 ...
.. ..- attr(*, "dimnames")=List of 2
.. .. ..$ : NULL
.. .. ..$ : chr [1:2] "Intercept" "X"
..$ qraux: num [1:2] 1.33 1.26
..$ rank : int 2
..$ pivot: int [1:2] 1 2
..$ tol : num 1e-07
..- attr(*, "class")= chr "qr"
> op <- options(); str(op)   # save first;
List of 60
 $ add.smooth           : logi TRUE
 $ bitmapType           : chr "Xlib"
 $ browser              : chr "/usr/bin/xdg-open"
 $ browserNLdisabled    : logi FALSE
 $ CBoundsCheck         : logi FALSE
 $ check.bounds         : logi FALSE
 $ citation.bibtex.max  : num 1
 $ continue             : chr "+ "
 $ contrasts            : Named chr [1:2] "contr.treatment" "contr.poly"
  ..- attr(*, "names")= chr [1:2] "unordered" "ordered"
 $ defaultPackages      : chr [1:6] "datasets" "utils" "grDevices" "graphics" ...
 $ demo.ask             : chr "default"
 $ deparse.cutoff       : int 60
 $ device               :function (file = ifelse(onefile, "Rplots.pdf", "Rplot%03d.pdf"), width, 
    height, onefile, family, title, fonts, version, paper, encoding, bg, 
    fg, pointsize, pagecentre, colormodel, useDingbats, useKerning, fillOddEven, 
    compress)  
 $ device.ask.default   : logi FALSE
 $ digits               : int 7
 $ dvipscmd             : chr "dvips"
 $ echo                 : logi TRUE
 $ editor               : chr "vi"
 $ encoding             : chr "native.enc"
 $ example.ask          : chr "default"
 $ expressions          : int 5000
 $ help.search.types    : chr [1:3] "vignette" "demo" "help"
 $ help.try.all.packages: logi FALSE
 $ HTTPUserAgent        : chr "R (3.0.0 x86_64-unknown-linux-gnu x86_64 linux-gnu)"
 $ internet.info        : num 2
 $ keep.source          : logi FALSE
 $ keep.source.pkgs     : logi FALSE
 $ locatorBell          : logi TRUE
 $ mailer               : chr "mailto"
 $ max.print            : int 99999
 $ menu.graphics        : logi TRUE
 $ na.action            : chr "na.omit"
 $ nwarnings            : int 50
 $ OutDec               : chr "."
 $ pager                : chr "/var/lib/stickshift/51915fc45973cabdbf00023c/app-root/data/R-3.0.0/bin/pager"
 $ papersize            : chr "a4"
 $ pdfviewer            : chr "/usr/bin/xdg-open"
 $ pkgType              : chr "source"
 $ printcmd             : chr "lpr"
 $ prompt               : chr "> "
 $ repos                : Named chr "@CRAN@"
  ..- attr(*, "names")= chr "CRAN"
 $ rl_word_breaks       : chr " \t\n\"\\'`><=%;,|&{()}"
 $ scipen               : num 0
 $ show.coef.Pvalues    : logi TRUE
 $ showErrorCalls       : logi TRUE
 $ show.error.messages  : logi TRUE
 $ show.signif.stars    : logi TRUE
 $ str                  :List of 3
  ..$ strict.width: chr "no"
  ..$ digits.d    : num 3
  ..$ vec.len     : num 4
 $ str.dendrogram.last  : chr "`"
 $ stringsAsFactors     : logi TRUE
 $ texi2dvi             : chr "texi2dvi"
 $ timeout              : num 60
 $ ts.eps               : num 1e-05
 $ ts.S.compat          : logi FALSE
 $ unzip                : chr "/usr/bin/unzip"
 $ useFancyQuotes       : logi TRUE
 $ verbose              : logi FALSE
 $ warn                 : num 1
 $ warning.length       : int 1000
 $ width                : int 80
>                            # otherwise internal options() is used.
> need.dev <-
+   !exists(".Device") || is.null(.Device) || .Device == "null device"
> { if(need.dev) postscript()
+   str(par())
+   if(need.dev) graphics.off()
+ }
List of 71
 $ xlog     : logi FALSE
 $ ylog     : logi FALSE
 $ adj      : num 0.5
 $ ann      : logi TRUE
 $ ask      : logi FALSE
 $ bg       : chr "transparent"
 $ bty      : chr "o"
 $ cex      : num 1
 $ cex.axis : num 1
 $ cex.lab  : num 1
 $ cex.main : num 1.2
 $ cex.sub  : num 1
 $ cin      : num [1:2] 0.15 0.2
 $ col      : chr "black"
 $ col.axis : chr "black"
 $ col.lab  : chr "black"
 $ col.main : chr "black"
 $ col.sub  : chr "black"
 $ cra      : num [1:2] 10.8 14.4
 $ crt      : num 0
 $ csi      : num 0.2
 $ cxy      : num [1:2] 0.837 3.642
 $ din      : num [1:2] 7 7
 $ err      : int 0
 $ family   : chr ""
 $ fg       : chr "black"
 $ fig      : num [1:4] 0 1 0 1
 $ fin      : num [1:2] 7 7
 $ font     : int 1
 $ font.axis: int 1
 $ font.lab : int 1
 $ font.main: int 2
 $ font.sub : int 1
 $ lab      : int [1:3] 5 5 7
 $ las      : int 0
 $ lend     : chr "round"
 $ lheight  : num 1
 $ ljoin    : chr "round"
 $ lmitre   : num 10
 $ lty      : chr "solid"
 $ lwd      : num 1
 $ mai      : num [1:4] 1.02 0.82 0.82 0.42
 $ mar      : num [1:4] 5.1 4.1 4.1 2.1
 $ mex      : num 1
 $ mfcol    : int [1:2] 1 1
 $ mfg      : int [1:4] 1 1 1 1
 $ mfrow    : int [1:2] 1 1
 $ mgp      : num [1:3] 3 1 0
 $ mkh      : num 0.001
 $ new      : logi FALSE
 $ oma      : num [1:4] 0 0 0 0
 $ omd      : num [1:4] 0 1 0 1
 $ omi      : num [1:4] 0 0 0 0
 $ pch      : int 1
 $ pin      : num [1:2] 5.76 5.16
 $ plt      : num [1:4] 0.117 0.94 0.146 0.883
 $ ps       : int 12
 $ pty      : chr "m"
 $ smo      : num 1
 $ srt      : num 0
 $ tck      : num NA
 $ tcl      : num -0.5
 $ usr      : num [1:4] 1943.81 1975.94 -3.48 90.48
 $ xaxp     : num [1:3] 1945 1975 6
 $ xaxs     : chr "r"
 $ xaxt     : chr "s"
 $ xpd      : logi FALSE
 $ yaxp     : num [1:3] 0 80 4
 $ yaxs     : chr "r"
 $ yaxt     : chr "s"
 $ ylbias   : num 0.2
> ch <- letters[1:12]; is.na(ch) <- 3:5
> str(ch) # character NA's
 chr [1:12] "a" "b" NA NA NA "f" "g" "h" "i" "j" "k" ...
> 
> str(list(a = "A", L = as.list(1:100)), list.len = 9)
List of 2
 $ a: chr "A"
 $ L:List of 100
  ..$ : int 1
  ..$ : int 2
  ..$ : int 3
  ..$ : int 4
  ..$ : int 5
  ..$ : int 6
  ..$ : int 7
  ..$ : int 8
  ..$ : int 9
  .. [list output truncated]
> nchar(longch <- paste(rep(letters,100), collapse = ""))
[1] 2600
> str(longch)
 chr "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvw"| __truncated__
> str(longch, nchar.max = 52)
 chr "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxy"| __truncated__
> 
> str(longch, strict.width = "wrap")
chr
   "abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstu"..
   __truncated__
> 
> ## Settings for narrow transcript :
> op <- options(width = 60,
+               str = strOptions(strict.width = "wrap"))
> str(lsfit(1:9,1:9))
List of 4
$ coefficients: Named num [1:2] 1.18e-15 1.00
..- attr(*, "names")= chr [1:2] "Intercept" "X"
$ residuals : num [1:9] -9.01e-16 1.72e-15 -2.47e-16
   -2.25e-16 -2.03e-16 ...
$ intercept : logi TRUE
$ qr :List of 6
..$ qt : num [1:9] -1.50e+01 7.75 -2.22e-16 0.00 2.22e-16
   ...
..$ qr : num [1:9, 1:2] -3 0.333 0.333 0.333 0.333 ...
.. ..- attr(*, "dimnames")=List of 2
.. .. ..$ : NULL
.. .. ..$ : chr [1:2] "Intercept" "X"
..$ qraux: num [1:2] 1.33 1.26
..$ rank : int 2
..$ pivot: int [1:2] 1 2
..$ tol : num 1e-07
..- attr(*, "class")= chr "qr"
> str(options())
List of 60
$ add.smooth : logi TRUE
$ bitmapType : chr "Xlib"
$ browser : chr "/usr/bin/xdg-open"
$ browserNLdisabled : logi FALSE
$ CBoundsCheck : logi FALSE
$ check.bounds : logi FALSE
$ citation.bibtex.max : num 1
$ continue : chr "+ "
$ contrasts : Named chr [1:2] "contr.treatment"
   "contr.poly"
..- attr(*, "names")= chr [1:2] "unordered" "ordered"
$ defaultPackages : chr [1:6] "datasets" "utils"
   "grDevices" "graphics" ...
$ demo.ask : chr "default"
$ deparse.cutoff : int 60
$ device :function (file = ifelse(onefile, "Rplots.pdf",
   "Rplot%03d.pdf"),
width, height, onefile, family, title, fonts, version,
paper, encoding, bg, fg, pointsize, pagecentre,
colormodel, useDingbats, useKerning, fillOddEven,
compress)
$ device.ask.default : logi FALSE
$ digits : int 7
$ dvipscmd : chr "dvips"
$ echo : logi TRUE
$ editor : chr "vi"
$ encoding : chr "native.enc"
$ example.ask : chr "default"
$ expressions : int 5000
$ help.search.types : chr [1:3] "vignette" "demo" "help"
$ help.try.all.packages: logi FALSE
$ HTTPUserAgent : chr "R (3.0.0 x86_64-unknown-linux-gnu
   x86_64 linux-gnu)"
$ internet.info : num 2
$ keep.source : logi FALSE
$ keep.source.pkgs : logi FALSE
$ locatorBell : logi TRUE
$ mailer : chr "mailto"
$ max.print : int 99999
$ menu.graphics : logi TRUE
$ na.action : chr "na.omit"
$ nwarnings : int 50
$ OutDec : chr "."
$ pager : chr
   "/var/lib/stickshift/51915fc45973cabdbf00023c/app-root"..
$ papersize : chr "a4"
$ pdfviewer : chr "/usr/bin/xdg-open"
$ pkgType : chr "source"
$ printcmd : chr "lpr"
$ prompt : chr "> "
$ repos : Named chr "@CRAN@"
..- attr(*, "names")= chr "CRAN"
$ rl_word_breaks : chr " \t\n\"\\'`><=%;,|&{()}"
$ scipen : num 0
$ show.coef.Pvalues : logi TRUE
$ showErrorCalls : logi TRUE
$ show.error.messages : logi TRUE
$ show.signif.stars : logi TRUE
$ str :List of 4
..$ strict.width: chr "wrap"
..$ digits.d : num 3
..$ vec.len : num 4
..$ formatNum :function (x, ...)
$ str.dendrogram.last : chr "`"
$ stringsAsFactors : logi TRUE
$ texi2dvi : chr "texi2dvi"
$ timeout : num 60
$ ts.eps : num 1e-05
$ ts.S.compat : logi FALSE
$ unzip : chr "/usr/bin/unzip"
$ useFancyQuotes : logi TRUE
$ verbose : logi FALSE
$ warn : num 1
$ warning.length : int 1000
$ width : int 60
> ## reset to previous:
> options(op)
> 
> 
> ## Don't show: 
>  ##-- Some "crazy" objects
>  str(array(1:5, dim = 20))
 int [1:20(1d)] 1 2 3 4 5 1 2 3 4 5 ...
>  str(factor(character(0)))
 Factor w/ 0 levels: 
>  str(as.data.frame(NULL))
'data.frame':	0 obs. of  0 variables
> ## End Don't show
> str(quote( { A+B; list(C, D) } ))
 language {  A + B; list(C, D) }
> 
> ## Don't show: 
> had.stats4 <- "package:stats4" %in% search()
> if(!had.stats4)
+    rs <- 
+ ## End Don't show
+ ## S4 classes :
+ require(stats4)
Loading required package: stats4
> x <- 0:10; y <- c(26, 17, 13, 12, 20, 5, 9, 8, 5, 4, 8)
> ll <- function(ymax = 15, xh = 6)
+       -sum(dpois(y, lambda=ymax/(1+x/xh), log=TRUE))
> fit <- mle(ll)
Warning in dpois(y, lambda = ymax/(1 + x/xh), log = TRUE) :
  NaNs produced
> str(fit)
Formal class 'mle' [package "stats4"] with 9 slots
  ..@ call     : language mle(minuslogl = ll)
  ..@ coef     : Named num [1:2] 24.99 3.06
  .. ..- attr(*, "names")= chr [1:2] "ymax" "xh"
  ..@ fullcoef : Named num [1:2] 24.99 3.06
  .. ..- attr(*, "names")= chr [1:2] "ymax" "xh"
  ..@ vcov     : num [1:2, 1:2] 17.85 -3.72 -3.72 1.07
  .. ..- attr(*, "dimnames")=List of 2
  .. .. ..$ : chr [1:2] "ymax" "xh"
  .. .. ..$ : chr [1:2] "ymax" "xh"
  ..@ min      : num 28.6
  ..@ details  :List of 6
  .. ..$ par        : Named num [1:2] 24.99 3.06
  .. .. ..- attr(*, "names")= chr [1:2] "ymax" "xh"
  .. ..$ value      : num 28.6
  .. ..$ counts     : Named int [1:2] 25 18
  .. .. ..- attr(*, "names")= chr [1:2] "function" "gradient"
  .. ..$ convergence: int 0
  .. ..$ message    : NULL
  .. ..$ hessian    : num [1:2, 1:2] 0.203 0.706 0.706 3.388
  .. .. ..- attr(*, "dimnames")=List of 2
  .. .. .. ..$ : chr [1:2] "ymax" "xh"
  .. .. .. ..$ : chr [1:2] "ymax" "xh"
  ..@ minuslogl:function (ymax = 15, xh = 6)  
  ..@ nobs     : int NA
  ..@ method   : chr "BFGS"
> ## Don't show: 
> if(!had.stats4 && rs) detach("package:stats4")
> ## End Don't show
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("summaryRprof")
> ### * summaryRprof
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: summaryRprof
> ### Title: Summarise Output of R Sampling Profiler
> ### Aliases: summaryRprof
> ### Keywords: utilities
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## Rprof() is not available on all platforms
> ##D Rprof(tmp <- tempfile())
> ##D example(glm)
> ##D Rprof()
> ##D summaryRprof(tmp)
> ##D unlink(tmp)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("txtProgressBar")
> ### * txtProgressBar
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: txtProgressBar
> ### Title: Text Progress Bar
> ### Aliases: txtProgressBar getTxtProgressBar setTxtProgressBar
> ###   close.txtProgressBar
> ### Keywords: utilities
> 
> ### ** Examples
> 
> 
> cleanEx()
> nameEx("url.show")
> ### * url.show
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: url.show
> ### Title: Display a text URL
> ### Aliases: url.show
> ### Keywords: file misc
> 
> ### ** Examples
> 
> ## Not run: url.show("http://lib.stat.cmu.edu/datasets/csb/ch3a.txt")
> 
> 
> 
> cleanEx()
> nameEx("vignette")
> ### * vignette
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: vignette
> ### Title: View or List Vignettes
> ### Aliases: vignette edit.vignette print.vignette vignettes
> ### Keywords: documentation
> 
> ### ** Examples
> 
> ## List vignettes from all *attached* packages
> vignette(all = FALSE)
no vignettes found

Use ‘vignette(all = TRUE)’
to list the vignettes in all *available* packages.
> 
> ## List vignettes from all *installed* packages (can take a long time!):
> vignette(all = TRUE)
Vignettes in package ‘Matrix’:

Comparisons             Comparisons of Least Squares calculation speeds
                        (source, pdf)
Design-issues           Design Issues in Matrix package Development
                        (source, pdf)
Intro2Matrix            2nd Introduction to the Matrix Package (source,
                        pdf)
Introduction            Introduction to the Matrix Package (source,
                        pdf)
sparseModels            Sparse Model Matrices (source, pdf)

Vignettes in package ‘rpart’:

longintro               Introduction to Rpart (source, pdf)
usercode                User Written Split Functions (source, pdf)

Vignettes in package ‘survival’:

timedep                 Using Time Dependent Covariates (source, pdf)

> 
> ## Not run: 
> ##D ## Open the grid intro vignette
> ##D vignette("grid")
> ##D 
> ##D ## The same
> ##D v1 <- vignette("grid")
> ##D print(v1)
> ##D 
> ##D ## Now let us have a closer look at the code
> ##D edit(v1)
> ##D 
> ##D ## An alternative way of extracting the code,
> ##D ## R file is written to current working directory
> ##D Stangle(v1$file)
> ##D 
> ##D ## A package can have more than one vignette (package grid has several):
> ##D vignette(package = "grid")
> ##D vignette("rotated")
> ##D ## The same, but without searching for it:
> ##D vignette("rotated", package = "grid")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("write.table")
> ### * write.table
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: write.table
> ### Title: Data Output
> ### Aliases: write.table write.csv write.csv2
> ### Keywords: print file
> 
> ### ** Examples
> 
> ## Not run: 
> ##D ## To write a CSV file for input to Excel one might use
> ##D x <- data.frame(a = I("a \" quote"), b = pi)
> ##D write.table(x, file = "foo.csv", sep = ",", col.names = NA,
> ##D             qmethod = "double")
> ##D ## and to read this file back into R one needs
> ##D read.table("foo.csv", header = TRUE, sep = ",", row.names = 1)
> ##D ## NB: you do need to specify a separator if qmethod = "double".
> ##D 
> ##D ### Alternatively
> ##D write.csv(x, file = "foo.csv")
> ##D read.csv("foo.csv", row.names = 1)
> ##D ## or without row names
> ##D write.csv(x, file = "foo.csv", row.names = FALSE)
> ##D read.csv("foo.csv")
> ##D 
> ##D ## To write a file in MacRoman for simple use in Mac Excel 2004/8
> ##D write.csv(x, file = "foo.csv", fileEncoding = "macroman")
> ##D ## or for Windows Excel 2007/10
> ##D write.csv(x, file = "foo.csv", fileEncoding = "UTF-16LE")
> ## End(Not run)
> 
> 
> ### * <FOOTER>
> ###
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  9.421 1.028 37.22 0.071 0.296 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')

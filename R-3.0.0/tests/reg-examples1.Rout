
R version 3.0.0 (2013-04-03) -- "Masked Marvel"
Copyright (C) 2013 The R Foundation for Statistical Computing
Platform: x86_64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ## For examples skipped in testing because they are 'random'
> 
> set.seed(1)
> if(.Platform$OS.type == "windows") options(pager = "console")
> 
> pdf("reg-examples-1.pdf", encoding = "ISOLatin1.enc")
> 
> 
> ## base
> example(Cstack_info)

Cstck_> ## No test: 
Cstck_> Cstack_info()
      size    current  direction eval_depth 
  10485760      24008          1          9 

Cstck_> ## End(No test)
Cstck_> 
Cstck_> 
> example(DateTimeClasses)

DtTmCl> ## No test: 
DtTmCl> (z <- Sys.time())             # the current date, as class "POSIXct"
[1] "2013-05-17 18:25:13 EDT"

DtTmCl> Sys.time() - 3600             # an hour ago
[1] "2013-05-17 17:25:13 EDT"

DtTmCl> as.POSIXlt(Sys.time(), "GMT") # the current time in GMT
[1] "2013-05-17 22:25:13 GMT"

DtTmCl> format(.leap.seconds)         # all 24 leap seconds in your timezone
 [1] "1972-06-30 20:00:00" "1972-12-31 19:00:00" "1973-12-31 19:00:00"
 [4] "1974-12-31 19:00:00" "1975-12-31 19:00:00" "1976-12-31 19:00:00"
 [7] "1977-12-31 19:00:00" "1978-12-31 19:00:00" "1979-12-31 19:00:00"
[10] "1981-06-30 20:00:00" "1982-06-30 20:00:00" "1983-06-30 20:00:00"
[13] "1985-06-30 20:00:00" "1987-12-31 19:00:00" "1989-12-31 19:00:00"
[16] "1990-12-31 19:00:00" "1992-06-30 20:00:00" "1993-06-30 20:00:00"
[19] "1994-06-30 20:00:00" "1995-12-31 19:00:00" "1997-06-30 20:00:00"
[22] "1998-12-31 19:00:00" "2005-12-31 19:00:00" "2008-12-31 19:00:00"
[25] "2012-06-30 20:00:00"

DtTmCl> print(.leap.seconds, tz = "PST8PDT")  # and in Seattle's
 [1] "1972-06-30 20:00:00 EDT" "1972-12-31 19:00:00 EST"
 [3] "1973-12-31 19:00:00 EST" "1974-12-31 19:00:00 EST"
 [5] "1975-12-31 19:00:00 EST" "1976-12-31 19:00:00 EST"
 [7] "1977-12-31 19:00:00 EST" "1978-12-31 19:00:00 EST"
 [9] "1979-12-31 19:00:00 EST" "1981-06-30 20:00:00 EDT"
[11] "1982-06-30 20:00:00 EDT" "1983-06-30 20:00:00 EDT"
[13] "1985-06-30 20:00:00 EDT" "1987-12-31 19:00:00 EST"
[15] "1989-12-31 19:00:00 EST" "1990-12-31 19:00:00 EST"
[17] "1992-06-30 20:00:00 EDT" "1993-06-30 20:00:00 EDT"
[19] "1994-06-30 20:00:00 EDT" "1995-12-31 19:00:00 EST"
[21] "1997-06-30 20:00:00 EDT" "1998-12-31 19:00:00 EST"
[23] "2005-12-31 19:00:00 EST" "2008-12-31 19:00:00 EST"
[25] "2012-06-30 20:00:00 EDT"

DtTmCl> ## look at *internal* representation of "POSIXlt" :
DtTmCl> leapS <- as.POSIXlt(.leap.seconds)

DtTmCl> names(leapS) ; is.list(leapS)
NULL
[1] TRUE

DtTmCl> ## str() "too smart" -->  need unclass(.):
DtTmCl> utils::str(unclass(leapS), vec.len = 7)
List of 9
 $ sec  : num [1:25] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ...
 $ min  : int [1:25] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ...
 $ hour : int [1:25] 20 19 19 19 19 19 19 19 19 20 20 20 20 19 19 19 20 20 ...
 $ mday : int [1:25] 30 31 31 31 31 31 31 31 31 30 30 30 30 31 31 31 30 30 ...
 $ mon  : int [1:25] 5 11 11 11 11 11 11 11 11 5 5 5 5 11 11 11 5 5 ...
 $ year : int [1:25] 72 72 73 74 75 76 77 78 79 81 82 83 85 87 89 90 92 93 ...
 $ wday : int [1:25] 5 0 1 2 3 5 6 0 1 2 3 4 0 4 0 1 2 3 ...
 $ yday : int [1:25] 181 365 364 364 364 365 364 364 364 180 180 180 180 364 364 364 181 180 ...
 $ isdst: int [1:25] 1 0 0 0 0 0 0 0 0 1 1 1 1 0 0 0 1 1 ...
 - attr(*, "tzone")= chr [1:3] "" "EST" "EDT"

DtTmCl> ## End(No test)
DtTmCl> 
DtTmCl> 
> example(Dates)

Dates> ## Not run: 
Dates> ##D (today <- Sys.Date())
Dates> ##D format(today, "%d %b %Y")  # with month as a word
Dates> ##D (tenweeks <- seq(today, length.out=10, by="1 week")) # next ten weeks
Dates> ##D weekdays(today)
Dates> ##D months(tenweeks)
Dates> ##D as.Date(.leap.seconds)
Dates> ## End(Not run)
Dates> 
Dates> 
> example(Ops.Date)

Ops.Dt> ## No test: 
Ops.Dt> (z <- Sys.Date())
[1] "2013-05-17"

Ops.Dt> z + 10
[1] "2013-05-27"

Ops.Dt> z < c("2009-06-01", "2010-01-01", "2015-01-01")
[1] FALSE FALSE  TRUE

Ops.Dt> ## End(No test)
Ops.Dt> 
Ops.Dt> 
> example(Random)

Random> ## No test: 
Random> require(stats)

Random> ## the default random seed is 626 integers, so only print a few
Random> runif(1); .Random.seed[1:6]; runif(1); .Random.seed[1:6]
[1] 0.2655087
[1]         403           1  1654269195 -1877109783  -961256264  1403523942
[1] 0.3721239
[1]         403           2  1654269195 -1877109783  -961256264  1403523942

Random> ## If there is no seed, a "random" new one is created:
Random> rm(.Random.seed); runif(1); .Random.seed[1:6]
[1] 0.8298292
[1]         403           1    49142447 -1283577755 -1945941988  1902659186

Random> ok <- RNGkind()

Random> RNGkind("Wich")  # (partial string matching on 'kind')

Random> ## This shows how 'runif(.)' works for Wichmann-Hill,
Random> ## using only R functions:
Random> 
Random> p.WH <- c(30269, 30307, 30323)

Random> a.WH <- c(  171,   172,   170)

Random> next.WHseed <- function(i.seed = .Random.seed[-1])
Random+   { (a.WH * i.seed) %% p.WH }

Random> my.runif1 <- function(i.seed = .Random.seed)
Random+   { ns <- next.WHseed(i.seed[-1]); sum(ns / p.WH) %% 1 }

Random> rs <- .Random.seed

Random> (WHs <- next.WHseed(rs[-1]))
[1] 10001 11029  4672

Random> u <- runif(1)

Random> stopifnot(
Random+  next.WHseed(rs[-1]) == .Random.seed[-1],
Random+  all.equal(u, my.runif1(rs))
Random+ )

Random> ## ----
Random> .Random.seed
[1]   400 10001 11029  4672

Random> RNGkind("Super") # matches  "Super-Duper"

Random> RNGkind()
[1] "Super-Duper" "Inversion"  

Random> .Random.seed # new, corresponding to  Super-Duper
[1]        402 1441191914 1522255971

Random> ## Reset:
Random> RNGkind(ok[1])

Random> ## ----
Random> sum(duplicated(runif(1e6))) # around 110 for default generator
[1] 122

Random> ## and we would expect about almost sure duplicates beyond about
Random> qbirthday(1 - 1e-6, classes = 2e9) # 235,000
[1] 235075

Random> ## End(No test)
Random> 
Random> 
> example(Sys.getpid)

Sys.gt> ## No test: 
Sys.gt> Sys.getpid()
[1] 12475

Sys.gt> ## End(No test)
Sys.gt> 
Sys.gt> 
> example(Sys.sleep)

Sys.sl> ## No test: 
Sys.sl> testit <- function(x)
Sys.sl+ {
Sys.sl+     p1 <- proc.time()
Sys.sl+     Sys.sleep(x)
Sys.sl+     proc.time() - p1 # The cpu usage should be negligible
Sys.sl+ }

Sys.sl> testit(3.7)
   user  system elapsed 
  0.001   0.000   3.703 

Sys.sl> ## End(No test)
Sys.sl> 
Sys.sl> 
> example(Sys.time)

Sys.tm> ## No test: 
Sys.tm> Sys.time()
[1] "2013-05-17 18:25:19 EDT"

Sys.tm> ## print with possibly greater accuracy:
Sys.tm> op <- options(digits.secs = 6)

Sys.tm> Sys.time()
[1] "2013-05-17 18:25:19.052093 EDT"

Sys.tm> options(op)

Sys.tm> ## locale-specific version of date()
Sys.tm> format(Sys.time(), "%a %b %d %X %Y")
[1] "Fri May 17 18:25:19 2013"

Sys.tm> Sys.Date()
[1] "2013-05-17"

Sys.tm> ## End(No test)
Sys.tm> 
Sys.tm> 
> example(as.POSIXlt)

a.POSI> ## No test: 
a.POSI> (z <- Sys.time())             # the current datetime, as class "POSIXct"
[1] "2013-05-17 18:25:19 EDT"

a.POSI> unclass(z)                    # a large integer
[1] 1368829519

a.POSI> floor(unclass(z)/86400)       # the number of days since 1970-01-01 (UTC)
[1] 15842

a.POSI> (now <- as.POSIXlt(Sys.time())) # the current datetime, as class "POSIXlt"
[1] "2013-05-17 18:25:19 EDT"

a.POSI> unlist(unclass(now))          # a list shown as a named vector
      sec       min      hour      mday       mon      year      wday      yday 
 19.12382  25.00000  18.00000  17.00000   4.00000 113.00000   5.00000 136.00000 
    isdst 
  1.00000 

a.POSI> now$year + 1900               # see ?DateTimeClasses
[1] 2013

a.POSI> months(now); weekdays(now)    # see ?months
[1] "May"
[1] "Friday"

a.POSI> ## suppose we have a time in seconds since 1960-01-01 00:00:00 GMT
a.POSI> ## (the origin used by SAS)
a.POSI> z <- 1472562988

a.POSI> # ways to convert this
a.POSI> as.POSIXct(z, origin = "1960-01-01")                # local
[1] "2006-08-30 14:16:28 EDT"

a.POSI> as.POSIXct(z, origin = "1960-01-01", tz = "GMT")    # in UTC
[1] "2006-08-30 13:16:28 GMT"

a.POSI> as.POSIXct(z, origin = ISOdatetime(1960,1,1,0,0,0)) # local
[1] "2006-08-30 14:16:28 EDT"

a.POSI> ISOdatetime(1960,1,1,0,0,0) + z                   # local
[1] "2006-08-30 14:16:28 EDT"

a.POSI> ## SPSS dates (R-help 2006-02-16)
a.POSI> z <- c(10485849600, 10477641600, 10561104000, 10562745600)

a.POSI> as.Date(as.POSIXct(z, origin = "1582-10-14", tz = "GMT"))
[1] "1915-01-26" "1914-10-23" "1917-06-15" "1917-07-04"

a.POSI> as.POSIXlt(Sys.time(), "GMT") # the current time in UTC
[1] "2013-05-17 22:25:19 GMT"

a.POSI> ## End(No test)
a.POSI> ## Not run: 
a.POSI> ##D ## These may not be correct names on your system
a.POSI> ##D as.POSIXlt(Sys.time(), "America/New_York")  # in New York
a.POSI> ##D as.POSIXlt(Sys.time(), "EST5EDT")           # alternative.
a.POSI> ##D as.POSIXlt(Sys.time(), "EST" )   # somewhere in Eastern Canada
a.POSI> ##D as.POSIXlt(Sys.time(), "HST")    # in Hawaii
a.POSI> ##D as.POSIXlt(Sys.time(), "Australia/Darwin")
a.POSI> ## End(Not run)
a.POSI> 
a.POSI> 
> example(difftime)

difftm> ## No test: 
difftm> (z <- Sys.time() - 3600)
[1] "2013-05-17 17:25:19 EDT"

difftm> Sys.time() - z                # just over 3600 seconds.
Time difference of 1 hours

difftm> ## time interval between releases of R 1.2.2 and 1.2.3.
difftm> ISOdate(2001, 4, 26) - ISOdate(2001, 2, 26)
Time difference of 59 days

difftm> as.difftime(c("0:3:20", "11:23:15"))
Time differences in mins
[1]   3.333333 683.250000
attr(,"tzone")
[1] ""

difftm> as.difftime(c("3:20", "23:15", "2:"), format= "%H:%M") # 3rd gives NA
Time differences in hours
[1]  3.333333 23.250000        NA
attr(,"tzone")
[1] ""

difftm> (z <- as.difftime(c(0,30,60), units = "mins"))
Time differences in mins
[1]  0 30 60

difftm> as.numeric(z, units = "secs")
[1]    0 1800 3600

difftm> as.numeric(z, units = "hours")
[1] 0.0 0.5 1.0

difftm> format(z)
[1] " 0 mins" "30 mins" "60 mins"

difftm> ## End(No test)
difftm> 
difftm> 
> example(format.Date)

frmt.D> ## No test: 
frmt.D> ## locale-specific version of the date
frmt.D> format(Sys.Date(), "%a %b %d")
[1] "Fri May 17"

frmt.D> ## End(No test)
frmt.D> 
frmt.D> ## read in date info in format 'ddmmmyyyy'
frmt.D> ## This will give NA(s) in some locales; setting the C locale
frmt.D> ## as in the commented lines will overcome this on most systems.
frmt.D> ## lct <- Sys.getlocale("LC_TIME"); Sys.setlocale("LC_TIME", "C")
frmt.D> x <- c("1jan1960", "2jan1960", "31mar1960", "30jul1960")

frmt.D> z <- as.Date(x, "%d%b%Y")

frmt.D> ## Sys.setlocale("LC_TIME", lct)
frmt.D> z
[1] "1960-01-01" "1960-01-02" "1960-03-31" "1960-07-30"

frmt.D> ## read in date/time info in format 'm/d/y'
frmt.D> dates <- c("02/27/92", "02/27/92", "01/14/92", "02/28/92", "02/01/92")

frmt.D> as.Date(dates, "%m/%d/%y")
[1] "1992-02-27" "1992-02-27" "1992-01-14" "1992-02-28" "1992-02-01"

frmt.D> ## date given as number of days since 1900-01-01 (a date in 1989)
frmt.D> as.Date(32768, origin = "1900-01-01")
[1] "1989-09-19"

frmt.D> ## Excel is said to use 1900-01-01 as day 1 (Windows default) or
frmt.D> ## 1904-01-01 as day 0 (Mac default), but this is complicated by Excel
frmt.D> ## treating 1900 as a leap year.
frmt.D> ## So for dates (post-1901) from Windows Excel
frmt.D> as.Date(35981, origin = "1899-12-30") # 1998-07-05
[1] "1998-07-05"

frmt.D> ## and Mac Excel
frmt.D> as.Date(34519, origin = "1904-01-01") # 1998-07-05
[1] "1998-07-05"

frmt.D> ## (these values come from http://support.microsoft.com/kb/214330)
frmt.D> 
frmt.D> ## Experiment shows that Matlab's origin is 719529 days before ours,
frmt.D> ## so Matlab day 734373 can be imported as
frmt.D> as.Date(734373, origin = "1970-01-01") - 719529
[1] "2010-08-23"

frmt.D> ## (value from http://www.mathworks.com/help/techdoc/matlab_prog/bspgcx2-1.html)
frmt.D> 
frmt.D> ## Timezone effect
frmt.D> z <- ISOdate(2010, 04, 13, c(0,12)) # midnight and midday UTC

frmt.D> as.Date(z) # in UTC
[1] "2010-04-13" "2010-04-13"

frmt.D> ## No test: 
frmt.D> ## these timezone names are common
frmt.D> as.Date(z, tz = "NZ")
[1] "2010-04-13" "2010-04-14"

frmt.D> as.Date(z, tz = "HST") # Hawaii
[1] "2010-04-12" "2010-04-13"

frmt.D> ## End(No test)
frmt.D> 
frmt.D> 
frmt.D> 
> example(Reduce) # funprog.Rd

Reduce> ## A general-purpose adder:
Reduce> add <- function(x) Reduce("+", x)

Reduce> add(list(1, 2, 3))
[1] 6

Reduce> ## Like sum(), but can also used for adding matrices etc., as it will
Reduce> ## use the appropriate '+' method in each reduction step.
Reduce> ## More generally, many generics meant to work on arbitrarily many
Reduce> ## arguments can be defined via reduction:
Reduce> FOO <- function(...) Reduce(FOO2, list(...))

Reduce> FOO2 <- function(x, y) UseMethod("FOO2")

Reduce> ## FOO() methods can then be provided via FOO2() methods.
Reduce> 
Reduce> ## A general-purpose cumulative adder:
Reduce> cadd <- function(x) Reduce("+", x, accumulate = TRUE)

Reduce> cadd(seq_len(7))
[1]  1  3  6 10 15 21 28

Reduce> ## A simple function to compute continued fractions:
Reduce> cfrac <- function(x) Reduce(function(u, v) u + 1 / v, x, right = TRUE)

Reduce> ## Continued fraction approximation for pi:
Reduce> cfrac(c(3, 7, 15, 1, 292))
[1] 3.141593

Reduce> ## Continued fraction approximation for Euler's number (e):
Reduce> cfrac(c(2, 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8))
[1] 2.718282

Reduce> ## Iterative function application:
Reduce> Funcall <- function(f, ...) f(...)

Reduce> ## Compute log(exp(acos(cos(0))
Reduce> Reduce(Funcall, list(log, exp, acos, cos), 0, right = TRUE)
[1] 0

Reduce> ## n-fold iterate of a function, functional style:
Reduce> Iterate <- function(f, n = 1)
Reduce+     function(x) Reduce(Funcall, rep.int(list(f), n), x, right = TRUE)

Reduce> ## Continued fraction approximation to the golden ratio:
Reduce> Iterate(function(x) 1 + 1 / x, 30)(1)
[1] 1.618034

Reduce> ## which is the same as
Reduce> cfrac(rep.int(1, 31))
[1] 1.618034

Reduce> ## Computing square root approximations for x as fixed points of the
Reduce> ## function t |-> (t + x / t) / 2, as a function of the initial value:
Reduce> asqrt <- function(x, n) Iterate(function(t) (t + x / t) / 2, n)

Reduce> asqrt(2, 30)(10) # Starting from a positive value => +sqrt(2)
[1] 1.414214

Reduce> asqrt(2, 30)(-1) # Starting from a negative value => -sqrt(2)
[1] -1.414214

Reduce> ## A list of all functions in the base environment:
Reduce> funs <- Filter(is.function, sapply(ls(baseenv()), get, baseenv()))

Reduce> ## Functions in base with more than 10 arguments:
Reduce> names(Filter(function(f) length(formals(args(f))) > 10, funs))
[1] "format.default"   "formatC"          "merge.data.frame" "prettyNum"       
[5] "scan"             "source"          

Reduce> ## Number of functions in base with a '...' argument:
Reduce> length(Filter(function(f)
Reduce+               any(names(formals(args(f))) %in% "..."),
Reduce+               funs))
[1] 417

Reduce> ## No test: 
Reduce> ## Find all objects in the base environment which are *not* functions:
Reduce> Filter(Negate(is.function),  sapply(ls(baseenv()), get, baseenv()))
$F
[1] FALSE

$LETTERS
 [1] "A" "B" "C" "D" "E" "F" "G" "H" "I" "J" "K" "L" "M" "N" "O" "P" "Q" "R" "S"
[20] "T" "U" "V" "W" "X" "Y" "Z"

$R.version
               _                           
platform       x86_64-unknown-linux-gnu    
arch           x86_64                      
os             linux-gnu                   
system         x86_64, linux-gnu           
status                                     
major          3                           
minor          0.0                         
year           2013                        
month          04                          
day            03                          
svn rev        62481                       
language       R                           
version.string R version 3.0.0 (2013-04-03)
nickname       Masked Marvel               

$R.version.string
[1] "R version 3.0.0 (2013-04-03)"

$T
[1] TRUE

$letters
 [1] "a" "b" "c" "d" "e" "f" "g" "h" "i" "j" "k" "l" "m" "n" "o" "p" "q" "r" "s"
[20] "t" "u" "v" "w" "x" "y" "z"

$month.abb
 [1] "Jan" "Feb" "Mar" "Apr" "May" "Jun" "Jul" "Aug" "Sep" "Oct" "Nov" "Dec"

$month.name
 [1] "January"   "February"  "March"     "April"     "May"       "June"     
 [7] "July"      "August"    "September" "October"   "November"  "December" 

$pi
[1] 3.141593

$version
               _                           
platform       x86_64-unknown-linux-gnu    
arch           x86_64                      
os             linux-gnu                   
system         x86_64, linux-gnu           
status                                     
major          3                           
minor          0.0                         
year           2013                        
month          04                          
day            03                          
svn rev        62481                       
language       R                           
version.string R version 3.0.0 (2013-04-03)
nickname       Masked Marvel               


Reduce> ## End(No test)
Reduce> 
Reduce> 
> example(gc)

gc> ## No test: 
gc> gc() #- do it now
          used (Mb) gc trigger (Mb) max used (Mb)
Ncells  324816 17.4     531268 28.4   467875 25.0
Vcells 1167982  9.0    3556386 27.2  3554377 27.2

gc> gcinfo(TRUE) #-- in the future, show when R does it
[1] FALSE

gc> x <- integer(100000); for(i in 1:18) x <- c(x, i)

gc> gcinfo(verbose = FALSE) #-- don't show it anymore
[1] TRUE

gc> gc(TRUE)
Garbage collection 43 = 32+4+7 (level 2) ... 
17.4 Mbytes of cons cells used (54%)
9.3 Mbytes of vectors used (34%)
          used (Mb) gc trigger (Mb) max used (Mb)
Ncells  324775 17.4     597831 32.0   467875 25.0
Vcells 1217897  9.3    3556386 27.2  3554377 27.2

gc> gc(reset = TRUE)
          used (Mb) gc trigger (Mb) max used (Mb)
Ncells  324782 17.4     597831 32.0   324782 17.4
Vcells 1217926  9.3    3556386 27.2  1217926  9.3

gc> ## End(No test)
gc> 
gc> 
> example(memory.profile)

mmry.p> ## No test: 
mmry.p> memory.profile()
       NULL      symbol    pairlist     closure environment     promise 
          1        7509      155077        4311         440        5087 
   language     special     builtin        char     logical     integer 
      52136          44         637        9701        6387       21015 
     double     complex   character         ...         any        list 
       1823          31       29979           0           0       14807 
 expression    bytecode externalptr     weakref         raw          S4 
          3       12742        1337         395         397         831 

mmry.p> ## End(No test)
mmry.p> 
mmry.p> 
> paste("Today is", date()) # from paste.Rd
[1] "Today is Fri May 17 18:25:20 2013"
> trunc(Sys.time(), "day") # from round.POSIXt.Rd
[1] "2013-05-17"
> example(srcref)

srcref> ## No test: 
srcref>  # has timestamp
srcref> src <- srcfile(system.file("DESCRIPTION", package = "base"))

srcref> summary(src)
/var/lib/stickshift/51915fc45973cabdbf00023c/app-root/data/R-3.0.0/library/base/DESCRIPTION 
Timestamp: 2013-05-17 17:41:02 EDT
Encoding: "native.enc"

srcref> getSrcLines(src, 1, 4)
[1] "Package: base"             "Version: 3.0.0"           
[3] "Priority: base"            "Title: The R Base Package"

srcref> ref <- srcref(src, c(1, 1, 2, 1000))

srcref> ref
Package: base
Version: 3.0.0

srcref> print(ref, useSource = FALSE)
<srcref: file "/var/lib/stickshift/51915fc45973cabdbf00023c/app-root/data/R-3.0.0/library/base/DESCRIPTION" chars 1:1 to 2:1000>

srcref> ## End(No test)
srcref> 
srcref> 
> example(strptime)

strptm> ## No test: 
strptm> ## locale-specific version of date()
strptm> format(Sys.time(), "%a %b %d %X %Y %Z")
[1] "Fri May 17 18:25:20 2013 EDT"

strptm> ## time to sub-second accuracy (if supported by the OS)
strptm> format(Sys.time(), "%H:%M:%OS3")
[1] "18:25:20.682"

strptm> ## read in date info in format 'ddmmmyyyy'
strptm> ## This will give NA(s) in some locales; setting the C locale
strptm> ## as in the commented lines will overcome this on most systems.
strptm> ## lct <- Sys.getlocale("LC_TIME"); Sys.setlocale("LC_TIME", "C")
strptm> x <- c("1jan1960", "2jan1960", "31mar1960", "30jul1960")

strptm> z <- strptime(x, "%d%b%Y")

strptm> ## Sys.setlocale("LC_TIME", lct)
strptm> z
[1] "1960-01-01" "1960-01-02" "1960-03-31" "1960-07-30"

strptm> ## read in date/time info in format 'm/d/y h:m:s'
strptm> dates <- c("02/27/92", "02/27/92", "01/14/92", "02/28/92", "02/01/92")

strptm> times <- c("23:03:20", "22:29:56", "01:03:30", "18:21:03", "16:56:26")

strptm> x <- paste(dates, times)

strptm> strptime(x, "%m/%d/%y %H:%M:%S")
[1] "1992-02-27 23:03:20" "1992-02-27 22:29:56" "1992-01-14 01:03:30"
[4] "1992-02-28 18:21:03" "1992-02-01 16:56:26"

strptm> ## time with fractional seconds
strptm> z <- strptime("20/2/06 11:16:16.683", "%d/%m/%y %H:%M:%OS")

strptm> z # prints without fractional seconds
[1] "2006-02-20 11:16:16"

strptm> op <- options(digits.secs = 3)

strptm> z
[1] "2006-02-20 11:16:16.683"

strptm> options(op)

strptm> ## timezones are not portable, but 'EST5EDT' comes pretty close.
strptm> (x <- strptime(c("2006-01-08 10:07:52", "2006-08-07 19:33:02"),
strptm+                "%Y-%m-%d %H:%M:%S", tz = "EST5EDT"))
[1] "2006-01-08 10:07:52 EST" "2006-08-07 19:33:02 EDT"

strptm> attr(x, "tzone")
[1] "EST5EDT" "EST"     "EDT"    

strptm> ## An RFC 822 header (Eastern Canada, during DST)
strptm> strptime("Tue, 23 Mar 2010 14:36:38 -0400",  "%a, %d %b %Y %H:%M:%S %z")
[1] "2010-03-23 14:36:38"

strptm> ## End(No test)
strptm> 
strptm> 
> example(sys.parent)

sys.pr> ## No test: 
sys.pr> require(utils)

sys.pr> ## Note: the first two examples will give different results
sys.pr> ## if run by example().
sys.pr> ff <- function(x) gg(x)

sys.pr> gg <- function(y) sys.status()

sys.pr> str(ff(1))
List of 3
 $ sys.calls  :Dotted pair list of 9
  ..$ : language example(sys.parent)
  ..$ : language source(tf, local, echo = echo, prompt.echo = paste0(prompt.prefix, getOption("prompt")),      continue.echo = paste0(prompt.prefix, getOption("continue")), verbose = verbose,  ...
  ..$ : language withVisible(eval(ei, envir))
  ..$ : language eval(ei, envir)
  ..$ : language eval(expr, envir, enclos)
  ..$ :length 2 str(ff(1))
  .. ..- attr(*, "srcref")=Class 'srcref'  atomic [1:8] 15 1 15 10 1 10 15 15
  .. .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x588a628> 
  ..$ : language ff(1)
  ..$ :length 2 gg(x)
  .. ..- attr(*, "srcref")=Class 'srcref'  atomic [1:8] 13 7 13 23 7 23 13 13
  .. .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x588a628> 
  ..$ :length 1 sys.status()
  .. ..- attr(*, "srcref")=Class 'srcref'  atomic [1:8] 14 7 14 30 7 30 14 14
  .. .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x588a628> 
 $ sys.parents: int [1:9] 0 1 2 2 4 0 0 7 8
 $ sys.frames :Dotted pair list of 9
  ..$ :<environment: 0x40b23f8> 
  ..$ :<environment: 0x5887448> 
  ..$ :<environment: 0x5975ff0> 
  ..$ :<environment: 0x5975e30> 
  ..$ :<environment: R_GlobalEnv> 
  ..$ :<environment: 0x5976ac0> 
  ..$ :<environment: 0x5976660> 
  ..$ :<environment: 0x5976510> 
  ..$ :<environment: 0x5976468> 

sys.pr> gg <- function(y) {
sys.pr+     ggg <- function() {
sys.pr+         cat("current frame is", sys.nframe(), "\n")
sys.pr+         cat("parents are", sys.parents(), "\n")
sys.pr+         print(sys.function(0)) # ggg
sys.pr+         print(sys.function(2)) # gg
sys.pr+     }
sys.pr+     if(y > 0) gg(y-1) else ggg()
sys.pr+ }

sys.pr> gg(3)
current frame is 10 
parents are 0 1 2 2 4 0 6 7 8 9 
function() {
        cat("current frame is", sys.nframe(), "\n")
        cat("parents are", sys.parents(), "\n")
        print(sys.function(0)) # ggg
        print(sys.function(2)) # gg
    }
<environment: 0x4333d58>
function (file, local = FALSE, echo = verbose, print.eval = echo, 
    verbose = getOption("verbose"), prompt.echo = getOption("prompt"), 
    max.deparse.length = 150, chdir = FALSE, encoding = getOption("encoding"), 
    continue.echo = getOption("continue"), skip.echo = 0, keep.source = getOption("keep.source")) 
{
    envir <- if (isTRUE(local)) {
        parent.frame()
    }
    else if (identical(local, FALSE)) {
        .GlobalEnv
    }
    else if (is.environment(local)) {
        local
    }
    else stop("'local' must be TRUE, FALSE or an environment")
    have_encoding <- !missing(encoding) && encoding != "unknown"
    if (!missing(echo)) {
        if (!is.logical(echo)) 
            stop("'echo' must be logical")
        if (!echo && verbose) {
            warning("'verbose' is TRUE, 'echo' not; ... coercing 'echo <- TRUE'")
            echo <- TRUE
        }
    }
    if (verbose) {
        cat("'envir' chosen:")
        print(envir)
    }
    ofile <- file
    from_file <- FALSE
    srcfile <- NULL
    if (is.character(file)) {
        if (identical(encoding, "unknown")) {
            enc <- utils::localeToCharset()
            encoding <- enc[length(enc)]
        }
        else enc <- encoding
        if (length(enc) > 1L) {
            encoding <- NA
            owarn <- options("warn")
            options(warn = 2)
            for (e in enc) {
                if (is.na(e)) 
                  next
                zz <- file(file, encoding = e)
                res <- tryCatch(readLines(zz, warn = FALSE), 
                  error = identity)
                close(zz)
                if (!inherits(res, "error")) {
                  encoding <- e
                  break
                }
            }
            options(owarn)
        }
        if (is.na(encoding)) 
            stop("unable to find a plausible encoding")
        if (verbose) 
            cat(gettextf("encoding = \"%s\" chosen", encoding), 
                "\n", sep = "")
        if (file == "") 
            file <- stdin()
        else {
            filename <- file
            file <- file(filename, "r", encoding = encoding)
            on.exit(close(file))
            if (isTRUE(keep.source)) {
                lines <- readLines(file, warn = FALSE)
                on.exit()
                close(file)
                srcfile <- srcfilecopy(filename, lines, file.info(filename)[1, 
                  "mtime"], isFile = TRUE)
            }
            else from_file <- TRUE
            loc <- utils::localeToCharset()[1L]
            encoding <- if (have_encoding) 
                switch(loc, `UTF-8` = "UTF-8", `ISO8859-1` = "latin1", 
                  "unknown")
            else "unknown"
        }
    }
    else {
        lines <- readLines(file, warn = FALSE)
        if (isTRUE(keep.source)) 
            srcfile <- srcfilecopy(deparse(substitute(file)), 
                lines)
        else srcfile <- deparse(substitute(file))
    }
    exprs <- if (!from_file) {
        if (length(lines)) 
            .Internal(parse(stdin(), n = -1, lines, "?", srcfile, 
                encoding))
        else expression()
    }
    else .Internal(parse(file, n = -1, NULL, "?", srcfile, encoding))
    on.exit()
    if (from_file) 
        close(file)
    Ne <- length(exprs)
    if (verbose) 
        cat("--> parsed", Ne, "expressions; now eval(.)ing them:\n")
    if (chdir) {
        if (is.character(ofile)) {
            isURL <- length(grep("^(ftp|http|file)://", ofile)) > 
                0L
            if (isURL) 
                warning("'chdir = TRUE' makes no sense for a URL")
            if (!isURL && (path <- dirname(ofile)) != ".") {
                owd <- getwd()
                if (is.null(owd)) 
                  stop("cannot 'chdir' as current directory is unknown")
                on.exit(setwd(owd), add = TRUE)
                setwd(path)
            }
        }
        else {
            warning("'chdir = TRUE' makes no sense for a connection")
        }
    }
    if (echo) {
        sd <- "\""
        nos <- "[^\"]*"
        oddsd <- paste0("^", nos, sd, "(", nos, sd, nos, sd, 
            ")*", nos, "$")
        trySrcLines <- function(srcfile, showfrom, showto) {
            lines <- try(suppressWarnings(getSrcLines(srcfile, 
                showfrom, showto)), silent = TRUE)
            if (inherits(lines, "try-error")) 
                lines <- character()
            lines
        }
    }
    yy <- NULL
    lastshown <- 0
    srcrefs <- attr(exprs, "srcref")
    for (i in seq_len(Ne + echo)) {
        tail <- i > Ne
        if (!tail) {
            if (verbose) 
                cat("\n>>>> eval(expression_nr.", i, ")\n\t\t =================\n")
            ei <- exprs[i]
        }
        if (echo) {
            nd <- 0
            srcref <- if (tail) 
                attr(exprs, "wholeSrcref")
            else if (i <= length(srcrefs)) 
                srcrefs[[i]]
            if (!is.null(srcref)) {
                if (i == 1) 
                  lastshown <- min(skip.echo, srcref[3L] - 1)
                if (lastshown < srcref[3L]) {
                  srcfile <- attr(srcref, "srcfile")
                  dep <- trySrcLines(srcfile, lastshown + 1, 
                    srcref[3L])
                  if (length(dep)) {
                    leading <- if (tail) 
                      length(dep)
                    else srcref[1L] - lastshown
                    lastshown <- srcref[3L]
                    while (length(dep) && length(grep("^[[:blank:]]*$", 
                      dep[1L]))) {
                      dep <- dep[-1L]
                      leading <- leading - 1L
                    }
                    dep <- paste0(rep.int(c(prompt.echo, continue.echo), 
                      c(leading, length(dep) - leading)), dep, 
                      collapse = "\n")
                    nd <- nchar(dep, "c")
                  }
                  else srcref <- NULL
                }
            }
            if (is.null(srcref)) {
                if (!tail) {
                  dep <- substr(paste(deparse(ei, control = "showAttributes"), 
                    collapse = "\n"), 12L, 1000000L)
                  dep <- paste0(prompt.echo, gsub("\n", paste0("\n", 
                    continue.echo), dep))
                  nd <- nchar(dep, "c") - 1L
                }
            }
            if (nd) {
                do.trunc <- nd > max.deparse.length
                dep <- substr(dep, 1L, if (do.trunc) 
                  max.deparse.length
                else nd)
                cat("\n", dep, if (do.trunc) 
                  paste(if (length(grep(sd, dep)) && length(grep(oddsd, 
                    dep))) 
                    " ...\" ..."
                  else " ....", "[TRUNCATED] "), "\n", sep = "")
            }
        }
        if (!tail) {
            yy <- withVisible(eval(ei, envir))
            i.symbol <- mode(ei[[1L]]) == "name"
            if (!i.symbol) {
                curr.fun <- ei[[1L]][[1L]]
                if (verbose) {
                  cat("curr.fun:")
                  utils::str(curr.fun)
                }
            }
            if (verbose >= 2) {
                cat(".... mode(ei[[1L]])=", mode(ei[[1L]]), "; paste(curr.fun)=")
                utils::str(paste(curr.fun))
            }
            if (print.eval && yy$visible) {
                if (isS4(yy$value)) 
                  methods::show(yy$value)
                else print(yy$value)
            }
            if (verbose) 
                cat(" .. after ", sQuote(deparse(ei, control = c("showAttributes", 
                  "useSource"))), "\n", sep = "")
        }
    }
    invisible(yy)
}
<bytecode: 0x3b336e0>
<environment: namespace:base>

sys.pr> t1 <- function() {
sys.pr+   aa <- "here"
sys.pr+   t2 <- function() {
sys.pr+     ## in frame 2 here
sys.pr+     cat("current frame is", sys.nframe(), "\n")
sys.pr+     str(sys.calls()) ## list with two components t1() and t2()
sys.pr+     cat("parents are frame numbers", sys.parents(), "\n") ## 0 1
sys.pr+     print(ls(envir = sys.frame(-1))) ## [1] "aa" "t2"
sys.pr+     invisible()
sys.pr+   }
sys.pr+   t2()
sys.pr+ }

sys.pr> t1()
current frame is 7 
Dotted pair list of 7
 $ : language example(sys.parent)
 $ : language source(tf, local, echo = echo, prompt.echo = paste0(prompt.prefix, getOption("prompt")),      continue.echo = paste0(prompt.prefix, getOption("continue")), verbose = verbose,  ...
 $ : language withVisible(eval(ei, envir))
 $ : language eval(ei, envir)
 $ : language eval(expr, envir, enclos)
 $ :length 1 t1()
  ..- attr(*, "srcref")=Class 'srcref'  atomic [1:8] 40 1 40 4 1 4 40 40
  .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x588a628> 
 $ :length 1 t2()
  ..- attr(*, "srcref")=Class 'srcref'  atomic [1:8] 38 3 38 6 3 6 38 38
  .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x588a628> 
parents are frame numbers 0 1 2 2 4 0 6 
[1] "aa" "t2"

sys.pr> test.sys.on.exit <- function() {
sys.pr+   on.exit(print(1))
sys.pr+   ex <- sys.on.exit()
sys.pr+   str(ex)
sys.pr+   cat("exiting...\n")
sys.pr+ }

sys.pr> test.sys.on.exit()
 language print(1)
exiting...
[1] 1

sys.pr> ## gives 'language print(1)', prints 1 on exit
sys.pr> 
sys.pr> ## An example where the parent is not the next frame up the stack
sys.pr> ## since method dispatch uses a frame.
sys.pr> as.double.foo <- function(x)
sys.pr+ {
sys.pr+     str(sys.calls())
sys.pr+     print(sys.frames())
sys.pr+     print(sys.parents())
sys.pr+     print(sys.frame(-1)); print(parent.frame())
sys.pr+     x
sys.pr+ }

sys.pr> t2 <- function(x) as.double(x)

sys.pr> a <- structure(pi, class = "foo")

sys.pr> t2(a)
Dotted pair list of 8
 $ : language example(sys.parent)
 $ : language source(tf, local, echo = echo, prompt.echo = paste0(prompt.prefix, getOption("prompt")),      continue.echo = paste0(prompt.prefix, getOption("continue")), verbose = verbose,  ...
 $ : language withVisible(eval(ei, envir))
 $ : language eval(ei, envir)
 $ : language eval(expr, envir, enclos)
 $ :length 2 t2(a)
  ..- attr(*, "srcref")=Class 'srcref'  atomic [1:8] 63 1 63 5 1 5 63 63
  .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x588a628> 
 $ :length 2 as.double(x)
  ..- attr(*, "srcref")=Class 'srcref'  atomic [1:8] 61 7 61 30 7 30 61 61
  .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x588a628> 
 $ :length 2 as.double.foo(x)
  ..- attr(*, "srcref")=Class 'srcref'  atomic [1:8] 61 7 61 30 7 30 61 61
  .. .. ..- attr(*, "srcfile")=Classes 'srcfilecopy', 'srcfile' <environment: 0x588a628> 
[[1]]
<environment: 0x40b23f8>

[[2]]
<environment: 0x5887448>

[[3]]
<environment: 0x33a8c98>

[[4]]
<environment: 0x33a8f38>

[[5]]
<environment: R_GlobalEnv>

[[6]]
<environment: 0x33a82a8>

[[7]]
<environment: 0x33a8430>

[[8]]
<environment: 0x33a8698>

[1] 0 1 2 2 4 0 6 6
<environment: 0x33a8430>
<environment: 0x33a82a8>
[1] 3.141593
attr(,"class")
[1] "foo"

sys.pr> ## End(No test)
sys.pr> 
sys.pr> 
> example(system.time)

systm.> require(stats)

systm.> ## No test: 
systm.> system.time(for(i in 1:100) mad(runif(1000)))
   user  system elapsed 
   0.03    0.00    0.10 

systm.> ## End(No test)
systm.> ## Not run: 
systm.> ##D exT <- function(n = 10000) {
systm.> ##D   # Purpose: Test if system.time works ok;   n: loop size
systm.> ##D   system.time(for(i in 1:n) x <- mean(rt(1000, df = 4)))
systm.> ##D }
systm.> ##D #-- Try to interrupt one of the following (using Ctrl-C / Escape):
systm.> ##D exT()                 #- about 4 secs on a 2.5GHz Xeon
systm.> ##D system.time(exT())    #~ +/- same
systm.> ## End(Not run)
systm.> 
systm.> 
> example(tempfile)

tempfl> ## No test: 
tempfl> tempfile(c("ab", "a b c"))   # give file name with spaces in!
[1] "/tmp//RtmpRy2qVH/ab30bba850fd2"     "/tmp//RtmpRy2qVH/a b c30bb76082a5a"

tempfl> tempfile("plot", fileext = c(".ps", ".pdf"))
[1] "/tmp//RtmpRy2qVH/plot30bb52f9275c.ps" 
[2] "/tmp//RtmpRy2qVH/plot30bb30ce7891.pdf"

tempfl> tempdir() # works on all platforms with a platform-dependent result
[1] "/tmp//RtmpRy2qVH"

tempfl> ## End(No test)
tempfl> 
tempfl> 
> example(weekdays)

wekdys> ## No test: 
wekdys> weekdays(.leap.seconds)
 [1] "Friday"    "Sunday"    "Monday"    "Tuesday"   "Wednesday" "Friday"   
 [7] "Saturday"  "Sunday"    "Monday"    "Tuesday"   "Wednesday" "Thursday" 
[13] "Sunday"    "Thursday"  "Sunday"    "Monday"    "Tuesday"   "Wednesday"
[19] "Thursday"  "Sunday"    "Monday"    "Thursday"  "Saturday"  "Wednesday"
[25] "Saturday" 

wekdys> months(.leap.seconds)
 [1] "June"     "December" "December" "December" "December" "December"
 [7] "December" "December" "December" "June"     "June"     "June"    
[13] "June"     "December" "December" "December" "June"     "June"    
[19] "June"     "December" "June"     "December" "December" "December"
[25] "June"    

wekdys> quarters(.leap.seconds)
 [1] "Q2" "Q4" "Q4" "Q4" "Q4" "Q4" "Q4" "Q4" "Q4" "Q2" "Q2" "Q2" "Q2" "Q4" "Q4"
[16] "Q4" "Q2" "Q2" "Q2" "Q4" "Q2" "Q4" "Q4" "Q4" "Q2"

wekdys> ## Julian Day Number (JDN, http://en.wikipedia.org/wiki/Julian_day)
wekdys> ## is the number of days since noon UTC on the first day of 4317 BC.
wekdys> ## in the proleptic Julian calendar.  To more recently, in
wekdys> ## 'Terrestrial Time' which differs from UTC by a few seconds
wekdys> ## See http://en.wikipedia.org/wiki/Terrestrial_Time
wekdys> julian(Sys.Date(), -2440588) # from a day
[1] 2456430
attr(,"origin")
[1] -2440588

wekdys> floor(as.numeric(julian(Sys.time())) + 2440587.5) # from a date-time
[1] 2456430

wekdys> ## End(No test)
wekdys> 
wekdys> 
> library(help="splines")

		Information on package 'splines'

Description:

Package:       splines
Version:       3.0.0
Priority:      base
Imports:       graphics, stats
Title:         Regression Spline Functions and Classes
Author:        Douglas M. Bates <bates@stat.wisc.edu> and William N.
               Venables <Bill.Venables@csiro.au>
Maintainer:    R Core Team <R-core@r-project.org>
Description:   Regression spline functions and classes
License:       Part of R 3.0.0
Built:         R 3.0.0; x86_64-unknown-linux-gnu; 2013-05-17 21:40:44
               UTC; unix

Index:

asVector                Coerce an Object to a Vector
backSpline              Monotone Inverse Spline
bs                      B-Spline Basis for Polynomial Splines
interpSpline            Create an Interpolation Spline
ns                      Generate a Basis Matrix for Natural Cubic
                        Splines
periodicSpline          Create a Periodic Interpolation Spline
polySpline              Piecewise Polynomial Spline Representation
predict.bSpline         Evaluate a Spline at New Values of x
predict.bs              Evaluate a Spline Basis
splineDesign            Design Matrix for B-splines
splineKnots             Knot Vector from a Spline
splineOrder             Determine the Order of a Spline
splines-package         Regression Spline Functions and Classes
xyVector                Construct an 'xyVector' Object

> 
> ## utils
> example(news)

news> ## Build a db of all R news entries.
news> db <- news()

news> ## Don't show: 
news>   vv <- capture.output(db)  # without an error

news> ## End Don't show
news> ## No test: 
news> ## Bug fixes with PR number in 2.11.0.
news> news(Version == "2.11.0" & grepl("^BUG", Category) & grepl("PR#", Text),
news+      db = db)
Changes in version 2.11.0:

BUG FIXES

    o   Using with(), eval() etc with a list with some unnamed elements now
	 works.  (PR#14035)

BUG FIXES

    o   cor(A, B) where A is n x 1 and B a 1-dimensional array segfaulted or
	 gave an internal error.  (The case cor(B, A) was PR#7116.)

BUG FIXES

    o   cut.POSIXt() applied to a start value after the DST transition on a
	 DST-change day could give the wrong time for argument breaks in
	 units of days or longer.  (PR#14208)

BUG FIXES

    o   do_par() UNPROTECTed too early (PR#14214)

BUG FIXES

    o   Subassignment x[[....]] <- y didn't check for a zero-length right
	 hand side, and inserted a rubbish value.  (PR#14217)

BUG FIXES

    o   Extreme tail behavior of, pbeta() {and hence pf()}, e.g., pbeta(x,
	 3, 2200, lower.tail=FALSE, log.p=TRUE) now returns finite values
	 instead of jumping to -Inf too early.  (PR#14230).

BUG FIXES

    o   read.fwf() misread multi-line records when n was specified.
	 (PR#14241)

BUG FIXES

    o   gzcon( <textConnection> ), an error, no longer damages the
	 connection (in a way to have it segfault).  (PR#14237)

BUG FIXES

    o   If xy[z].coords (used internally by many graphics functions) are
	 given a list as x, they now check that the list has suitable names
	 and give a more informative error message.  (PR#13936)

news> ## Which categories have been in use? % R-core maybe should standardize a bit more
news> sort(table(db[, "Category"]), decreasing = TRUE)

                    NEW FEATURES                        BUG FIXES 
                             663                              582 
          DEPRECATED AND DEFUNCT                     INSTALLATION 
                              67                               67 
                       UTILITIES             PACKAGE INSTALLATION 
                              54                               45 
            DEPRECATED & DEFUNCT               C-LEVEL FACILITIES 
                              44                               30 
SIGNIFICANT USER-VISIBLE CHANGES         PERFORMANCE IMPROVEMENTS 
                              22                               18 
                GRAPHICS DEVICES           HELP & Rd FILE CHANGES 
                              17                               16 
              SWEAVE & VIGNETTES                     LONG VECTORS 
                              16                               13 
                     COMPRESSION              REGULAR EXPRESSIONS 
                              11                               10 
                PACKAGE parallel             INTERNATIONALIZATION 
                               8                                6 
                  SWEAVE CHANGES                   CODE MIGRATION 
                               5                                3 
        WINDOWS-SPECIFIC CHANGES                          LICENCE 
                               2                                1 

news> ## Entries with version >= 2.10.1 (including "2.10.1 patched"):
news> table(news(Version >= "2.10.1", db = db)$Version)

        2.10.1 2.10.1 patched         2.11.0         2.11.1 2.11.1 patched 
            43             35            132             29             26 
        2.12.0         2.12.1         2.12.2 2.12.2 patched         2.13.0 
           153             42             47              9            155 
        2.13.1         2.13.2         2.14.0         2.14.1         2.14.2 
            49             33            196             34             33 
        2.15.0         2.15.1         2.15.2         2.15.3          3.0.0 
            95             67            102             48            219 

news> ## End(No test)
news> 
news> 
> example(packageDescription)

pckgDs> ## No test: 
pckgDs> packageDescription("stats")
Package: stats
Version: 3.0.0
Priority: base
Title: The R Stats Package
Author: R Core Team and contributors worldwide
Maintainer: R Core Team <R-core@r-project.org>
Description: R statistical functions
License: Part of R 3.0.0
Built: R 3.0.0; x86_64-unknown-linux-gnu; 2013-05-17 21:35:11 UTC; unix

-- File: /var/lib/stickshift/51915fc45973cabdbf00023c/app-root/data/R-3.0.0/library/stats/Meta/package.rds 

pckgDs> packageDescription("stats", fields = c("Package", "Version"))
Package: stats
Version: 3.0.0

-- File: /var/lib/stickshift/51915fc45973cabdbf00023c/app-root/data/R-3.0.0/library/stats/Meta/package.rds 
-- Fields read: Package, Version

pckgDs> packageDescription("stats", fields = "Version")
[1] "3.0.0"

pckgDs> packageDescription("stats", fields = "Version", drop = FALSE)
Version: 3.0.0

-- File: /var/lib/stickshift/51915fc45973cabdbf00023c/app-root/data/R-3.0.0/library/stats/Meta/package.rds 
-- Fields read: Version

pckgDs> if(packageVersion("MASS") < "7.3")
pckgDs+   message("you need to update 'MASS'")

pckgDs> ## End(No test)
pckgDs> 
pckgDs> 
> example(sessionInfo)

sssnIn> ## No test: 
sssnIn> sessionInfo()
R version 3.0.0 (2013-04-03)
Platform: x86_64-unknown-linux-gnu (64-bit)

locale:
[1] C

attached base packages:
[1] stats     graphics  grDevices utils     datasets  methods   base     

loaded via a namespace (and not attached):
[1] tools_3.0.0

sssnIn> toLatex(sessionInfo(), locale = FALSE)
\begin{itemize}\raggedright
  \item R version 3.0.0 (2013-04-03), \verb|x86_64-unknown-linux-gnu|
  \item Base packages: base, datasets, grDevices, graphics, methods,
    stats, utils
  \item Loaded via a namespace (and not attached): tools~3.0.0
\end{itemize}

sssnIn> ## End(No test)
sssnIn> 
sssnIn> 
> 
> ## datasets
> example(JohnsonJohnson)

JhnsnJ> ## No test: 
JhnsnJ> require(stats); require(graphics)

JhnsnJ> JJ <- log10(JohnsonJohnson)

JhnsnJ> plot(JJ)

JhnsnJ> ## This example gives a possible-non-convergence warning on some
JhnsnJ> ## platforms, but does seem to converge on x86 Linux and Windows.
JhnsnJ> (fit <- StructTS(JJ, type = "BSM"))

Call:
StructTS(x = JJ, type = "BSM")

Variances:
    level      slope       seas    epsilon  
1.948e-04  6.548e-06  4.138e-04  2.647e-04  

JhnsnJ> tsdiag(fit)

JhnsnJ> sm <- tsSmooth(fit)

JhnsnJ> plot(cbind(JJ, sm[, 1], sm[, 3]-0.5), plot.type = "single",
JhnsnJ+      col = c("black", "green", "blue"))

JhnsnJ> abline(h = -0.5, col = "grey60")

JhnsnJ> monthplot(fit)

JhnsnJ> ## End(No test)
JhnsnJ> 
JhnsnJ> 
> example(ability.cov)

ablty.> ## No test: 
ablty.> require(stats)

ablty.> (ability.FA <- factanal(factors = 1, covmat = ability.cov))

Call:
factanal(factors = 1, covmat = ability.cov)

Uniquenesses:
general picture  blocks    maze reading   vocab 
  0.535   0.853   0.748   0.910   0.232   0.280 

Loadings:
        Factor1
general 0.682  
picture 0.384  
blocks  0.502  
maze    0.300  
reading 0.877  
vocab   0.849  

               Factor1
SS loadings      2.443
Proportion Var   0.407

Test of the hypothesis that 1 factor is sufficient.
The chi square statistic is 75.18 on 9 degrees of freedom.
The p-value is 1.46e-12 

ablty.> update(ability.FA, factors = 2)

Call:
factanal(factors = 2, covmat = ability.cov)

Uniquenesses:
general picture  blocks    maze reading   vocab 
  0.455   0.589   0.218   0.769   0.052   0.334 

Loadings:
        Factor1 Factor2
general 0.499   0.543  
picture 0.156   0.622  
blocks  0.206   0.860  
maze    0.109   0.468  
reading 0.956   0.182  
vocab   0.785   0.225  

               Factor1 Factor2
SS loadings      1.858   1.724
Proportion Var   0.310   0.287
Cumulative Var   0.310   0.597

Test of the hypothesis that 2 factors are sufficient.
The chi square statistic is 6.11 on 4 degrees of freedom.
The p-value is 0.191 

ablty.> ## The signs of factors and hence the signs of correlations are
ablty.> ## arbitrary with promax rotation.
ablty.> update(ability.FA, factors = 2, rotation = "promax")

Call:
factanal(factors = 2, covmat = ability.cov, rotation = "promax")

Uniquenesses:
general picture  blocks    maze reading   vocab 
  0.455   0.589   0.218   0.769   0.052   0.334 

Loadings:
        Factor1 Factor2
general  0.364   0.470 
picture          0.671 
blocks           0.932 
maze             0.508 
reading  1.023         
vocab    0.811         

               Factor1 Factor2
SS loadings      1.853   1.807
Proportion Var   0.309   0.301
Cumulative Var   0.309   0.610

Factor Correlations:
        Factor1 Factor2
Factor1   1.000   0.557
Factor2   0.557   1.000

Test of the hypothesis that 2 factors are sufficient.
The chi square statistic is 6.11 on 4 degrees of freedom.
The p-value is 0.191 

ablty.> ## End(No test)
ablty.> 
ablty.> 
> 
> ## grDevices
> if(.Platform$OS.type == "windows") {
+     example(windowsFonts)
+ } else {
+     example(X11Fonts)
+     example(quartzFonts)
+ }

X11Fnt> X11Fonts()
$serif
[1] "-*-times-%s-%s-*-*-%d-*-*-*-*-*-*-*"

$sans
[1] "-*-helvetica-%s-%s-*-*-%d-*-*-*-*-*-*-*"

$mono
[1] "-*-courier-%s-%s-*-*-%d-*-*-*-*-*-*-*"

$Times
[1] "-adobe-times-%s-%s-*-*-%d-*-*-*-*-*-*-*"

$Helvetica
[1] "-adobe-helvetica-%s-%s-*-*-%d-*-*-*-*-*-*-*"

$CyrTimes
[1] "-cronyx-times-%s-%s-*-*-%d-*-*-*-*-*-*-*"

$CyrHelvetica
[1] "-cronyx-helvetica-%s-%s-*-*-%d-*-*-*-*-*-*-*"

$Arial
[1] "-monotype-arial-%s-%s-*-*-%d-*-*-*-*-*-*-*"

$Mincho
[1] "-*-mincho-%s-%s-*-*-%d-*-*-*-*-*-*-*"


X11Fnt> X11Fonts("mono")
$mono
[1] "-*-courier-%s-%s-*-*-%d-*-*-*-*-*-*-*"


X11Fnt> utopia <- X11Font("-*-utopia-*-*-*-*-*-*-*-*-*-*-*-*")

X11Fnt> X11Fonts(utopia = utopia)

qrtzFn> quartzFonts()
$serif
[1] "Times-Roman"      "Times-Bold"       "Times-Italic"     "Times-BoldItalic"

$sans
[1] "Helvetica"             "Helvetica-Bold"        "Helvetica-Oblique"    
[4] "Helvetica-BoldOblique"

$mono
[1] "Courier"             "Courier-Bold"        "Courier-Oblique"    
[4] "Courier-BoldOblique"


qrtzFn> quartzFonts("mono")
$mono
[1] "Courier"             "Courier-Bold"        "Courier-Oblique"    
[4] "Courier-BoldOblique"


qrtzFn> ## Not run: 
qrtzFn> ##D ## for CJK locales you can use something like
qrtzFn> ##D quartzFonts(sans = quartzFont(rep("AppleGothic", 4)),
qrtzFn> ##D             serif = quartzFont(rep("AppleMyungjp", 4)))
qrtzFn> ##D ## since the default fonts may well not have the glyphs needed
qrtzFn> ## End(Not run)
qrtzFn> 
qrtzFn> 
> 
> library(tools)
> example(Rdutils)
Warning message:
In example(Rdutils) : no help found for 'Rdutils'
> example(fileutils)
Warning message:
In example(fileutils) : no help found for 'fileutils'
> ## results are location- and OS-specific
> example(parseLatex) # charset-specific

prsLtx> ## No test: 
prsLtx> latex <- parseLatex("fa\\c{c}ile")

prsLtx> deparseLatex(latexToUtf8(latex))
[1] "fa<U+00E7>ile"

prsLtx> ## End(No test)
prsLtx> 
prsLtx> 
> 
> proc.time()
   user  system elapsed 
  5.900   0.382  24.608 
> 
